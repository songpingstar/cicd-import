{
    "instance_id": "geldata__gel-8721",
    "patch": "diff --git a/edb/server/protocol/auth_ext/http.py b/edb/server/protocol/auth_ext/http.py\nindex d4bbf71adc8..b131d1d8317 100644\n--- a/edb/server/protocol/auth_ext/http.py\n+++ b/edb/server/protocol/auth_ext/http.py\n@@ -435,6 +435,14 @@ async def handle_callback(\n             refresh_token,\n             id_token,\n         ) = await oauth_client.handle_callback(code, self._get_callback_url())\n+        if new_identity:\n+            await self._maybe_send_webhook(\n+                webhook.IdentityCreated(\n+                    event_id=str(uuid.uuid4()),\n+                    timestamp=datetime.datetime.now(datetime.timezone.utc),\n+                    identity_id=identity.id,\n+                )\n+            )\n         pkce_code = await pkce.link_identity_challenge(\n             self.db, identity.id, challenge\n         )\n",
    "repo": "geldata/gel",
    "base_commit": "4a5f17379884d7a54e6fee20c1d9af2839a8d8fa",
    "hints_text": "",
    "created_at": "2025-05-20T11:48:13Z",
    "test_patch": "diff --git a/tests/test_http_ext_auth.py b/tests/test_http_ext_auth.py\nindex f43f9dd9f0d..9b51e530361 100644\n--- a/tests/test_http_ext_auth.py\n+++ b/tests/test_http_ext_auth.py\n@@ -704,166 +704,231 @@ async def test_http_auth_ext_github_unknown_provider_01(self):\n             )\n \n     async def test_http_auth_ext_github_callback_01(self):\n-        with self.http_con() as http_con:\n-            provider_config = await self.get_builtin_provider_config_by_name(\n-                \"oauth_github\"\n+        base_url = self.mock_net_server.get_base_url().rstrip(\"/\")\n+        webhook_url = f\"{base_url}/webhook-01\"\n+        await self.con.query(\n+            \"\"\"\n+            CONFIGURE CURRENT DATABASE\n+            INSERT ext::auth::WebhookConfig {\n+                url := <str>$url,\n+                events := {\n+                    ext::auth::WebhookEvent.IdentityCreated,\n+                },\n+            };\n+            \"\"\",\n+            url=webhook_url,\n+        )\n+        provider_config = await self.get_builtin_provider_config_by_name(\n+            \"oauth_github\"\n+        )\n+        provider_name = provider_config.name\n+        client_id = provider_config.client_id\n+        client_secret = GITHUB_SECRET\n+\n+        now = utcnow()\n+        webhook_request = (\n+            \"POST\",\n+            base_url,\n+            \"/webhook-01\",\n+        )\n+        self.mock_net_server.register_route_handler(*webhook_request)(\n+            (\n+                \"\",\n+                204,\n             )\n-            provider_name = provider_config.name\n-            client_id = provider_config.client_id\n-            client_secret = GITHUB_SECRET\n+        )\n \n-            now = utcnow()\n-            token_request = (\n-                \"POST\",\n-                \"https://github.com\",\n-                \"login/oauth/access_token\",\n+        token_request = (\n+            \"POST\",\n+            \"https://github.com\",\n+            \"login/oauth/access_token\",\n+        )\n+        self.mock_oauth_server.register_route_handler(*token_request)(\n+            (\n+                json.dumps(\n+                    {\n+                        \"access_token\": \"github_access_token\",\n+                        \"scope\": \"read:user\",\n+                        \"token_type\": \"bearer\",\n+                    }\n+                ),\n+                200,\n             )\n-            self.mock_oauth_server.register_route_handler(*token_request)(\n-                (\n-                    json.dumps(\n-                        {\n-                            \"access_token\": \"github_access_token\",\n-                            \"scope\": \"read:user\",\n-                            \"token_type\": \"bearer\",\n-                        }\n-                    ),\n-                    200,\n-                )\n+        )\n+\n+        user_request = (\"GET\", \"https://api.github.com\", \"user\")\n+        self.mock_oauth_server.register_route_handler(*user_request)(\n+            (\n+                json.dumps(\n+                    {\n+                        \"id\": 1,\n+                        \"login\": \"octocat\",\n+                        \"name\": \"monalisa octocat\",\n+                        \"email\": \"octocat@example.com\",\n+                        \"avatar_url\": \"https://example.com/example.jpg\",\n+                        \"updated_at\": now.isoformat(),\n+                    }\n+                ),\n+                200,\n             )\n+        )\n+        await self._wait_for_db_config(\"ext::auth::AuthConfig::webhooks\")\n+        try:\n+            with self.http_con() as http_con:\n \n-            user_request = (\"GET\", \"https://api.github.com\", \"user\")\n-            self.mock_oauth_server.register_route_handler(*user_request)(\n-                (\n-                    json.dumps(\n-                        {\n-                            \"id\": 1,\n-                            \"login\": \"octocat\",\n-                            \"name\": \"monalisa octocat\",\n-                            \"email\": \"octocat@example.com\",\n-                            \"avatar_url\": \"https://example.com/example.jpg\",\n-                            \"updated_at\": now.isoformat(),\n-                        }\n-                    ),\n-                    200,\n+                challenge = (\n+                    base64.urlsafe_b64encode(\n+                        hashlib.sha256(\n+                            base64.urlsafe_b64encode(os.urandom(43)).rstrip(\n+                                b'='\n+                            )\n+                        ).digest()\n+                    )\n+                    .rstrip(b'=')\n+                    .decode()\n+                )\n+                await self.con.query(\n+                    \"\"\"\n+                    insert ext::auth::PKCEChallenge {\n+                        challenge := <str>$challenge,\n+                    }\n+                    \"\"\",\n+                    challenge=challenge,\n                 )\n-            )\n \n-            challenge = (\n-                base64.urlsafe_b64encode(\n-                    hashlib.sha256(\n-                        base64.urlsafe_b64encode(os.urandom(43)).rstrip(b'=')\n-                    ).digest()\n+                state_claims = auth_jwt.OAuthStateToken(\n+                    provider=provider_name,\n+                    redirect_to=f\"{self.http_addr}/some/path\",\n+                    challenge=challenge,\n                 )\n-                .rstrip(b'=')\n-                .decode()\n-            )\n-            await self.con.query(\n-                \"\"\"\n-                insert ext::auth::PKCEChallenge {\n-                    challenge := <str>$challenge,\n-                }\n-                \"\"\",\n-                challenge=challenge,\n-            )\n+                state_token = state_claims.sign(self.signing_key())\n \n-            state_claims = auth_jwt.OAuthStateToken(\n-                provider=provider_name,\n-                redirect_to=f\"{self.http_addr}/some/path\",\n-                challenge=challenge,\n-            )\n-            state_token = state_claims.sign(self.signing_key())\n+                data, headers, status = self.http_con_request(\n+                    http_con,\n+                    {\"state\": state_token, \"code\": \"abc123\"},\n+                    path=\"callback\",\n+                )\n \n-            data, headers, status = self.http_con_request(\n-                http_con,\n-                {\"state\": state_token, \"code\": \"abc123\"},\n-                path=\"callback\",\n-            )\n+                self.assertEqual(data, b\"\")\n+                self.assertEqual(status, 302)\n \n-            self.assertEqual(data, b\"\")\n-            self.assertEqual(status, 302)\n+                location = headers.get(\"location\")\n+                assert location is not None\n+                server_url = urllib.parse.urlparse(self.http_addr)\n+                url = urllib.parse.urlparse(location)\n+                self.assertEqual(url.scheme, server_url.scheme)\n+                self.assertEqual(url.hostname, server_url.hostname)\n+                self.assertEqual(url.path, f\"{server_url.path}/some/path\")\n+\n+                requests_for_token = self.mock_oauth_server.requests[\n+                    token_request\n+                ]\n+                self.assertEqual(len(requests_for_token), 1)\n+                body = requests_for_token[0].body\n+                assert body is not None\n+                self.assertEqual(\n+                    json.loads(body),\n+                    {\n+                        \"grant_type\": \"authorization_code\",\n+                        \"code\": \"abc123\",\n+                        \"client_id\": client_id,\n+                        \"client_secret\": client_secret,\n+                        \"redirect_uri\": f\"{self.http_addr}/callback\",\n+                    },\n+                )\n \n-            location = headers.get(\"location\")\n-            assert location is not None\n-            server_url = urllib.parse.urlparse(self.http_addr)\n-            url = urllib.parse.urlparse(location)\n-            self.assertEqual(url.scheme, server_url.scheme)\n-            self.assertEqual(url.hostname, server_url.hostname)\n-            self.assertEqual(url.path, f\"{server_url.path}/some/path\")\n+                requests_for_user = self.mock_oauth_server.requests[\n+                    user_request\n+                ]\n+                self.assertEqual(len(requests_for_user), 1)\n+                self.assertEqual(\n+                    requests_for_user[0].headers[\"authorization\"],\n+                    \"Bearer github_access_token\",\n+                )\n \n-            requests_for_token = self.mock_oauth_server.requests[token_request]\n-            self.assertEqual(len(requests_for_token), 1)\n-            body = requests_for_token[0].body\n-            assert body is not None\n-            self.assertEqual(\n-                json.loads(body),\n-                {\n-                    \"grant_type\": \"authorization_code\",\n-                    \"code\": \"abc123\",\n-                    \"client_id\": client_id,\n-                    \"client_secret\": client_secret,\n-                    \"redirect_uri\": f\"{self.http_addr}/callback\",\n-                },\n-            )\n+                identity = await self.con.query(\n+                    \"\"\"\n+                    SELECT ext::auth::Identity\n+                    FILTER .subject = '1'\n+                    AND .issuer = 'https://github.com'\n+                    \"\"\"\n+                )\n+                self.assertEqual(len(identity), 1)\n \n-            requests_for_user = self.mock_oauth_server.requests[user_request]\n-            self.assertEqual(len(requests_for_user), 1)\n-            self.assertEqual(\n-                requests_for_user[0].headers[\"authorization\"],\n-                \"Bearer github_access_token\",\n-            )\n+                # Test Webhook side effect\n+                async for tr in self.try_until_succeeds(\n+                    delay=2, timeout=120, ignore=(KeyError, AssertionError)\n+                ):\n+                    async with tr:\n+                        requests_for_webhook = self.mock_net_server.requests[\n+                            webhook_request\n+                        ]\n+                        self.assertEqual(len(requests_for_webhook), 1)\n \n-            identity = await self.con.query(\n-                \"\"\"\n-                SELECT ext::auth::Identity\n-                FILTER .subject = '1'\n-                AND .issuer = 'https://github.com'\n-                \"\"\"\n-            )\n-            self.assertEqual(len(identity), 1)\n+                body = requests_for_webhook[0].body\n+                self.assertIsNotNone(body)\n+                event_data = json.loads(body)\n+                self.assertEqual(\n+                    event_data[\"event_type\"], \"IdentityCreated\"\n+                )\n+                self.assertEqual(\n+                    event_data[\"identity_id\"], str(identity[0].id)\n+                )\n \n-            pkce_object = await self.con.query(\n-                \"\"\"\n-                SELECT ext::auth::PKCEChallenge\n-                { id, auth_token, refresh_token }\n-                filter .identity.id = <uuid>$identity_id\n-                \"\"\",\n-                identity_id=identity[0].id,\n-            )\n+                pkce_object = await self.con.query(\n+                    \"\"\"\n+                    SELECT ext::auth::PKCEChallenge\n+                    { id, auth_token, refresh_token }\n+                    filter .identity.id = <uuid>$identity_id\n+                    \"\"\",\n+                    identity_id=identity[0].id,\n+                )\n \n-            self.assertEqual(len(pkce_object), 1)\n-            self.assertEqual(pkce_object[0].auth_token, \"github_access_token\")\n-            self.assertIsNone(pkce_object[0].refresh_token)\n+                self.assertEqual(len(pkce_object), 1)\n+                self.assertEqual(\n+                    pkce_object[0].auth_token, \"github_access_token\"\n+                )\n+                self.assertIsNone(pkce_object[0].refresh_token)\n \n-            self.mock_oauth_server.register_route_handler(*user_request)(\n-                (\n-                    json.dumps(\n-                        {\n-                            \"id\": 1,\n-                            \"login\": \"octocat\",\n-                            \"name\": \"monalisa octocat\",\n-                            \"email\": \"octocat+2@example.com\",\n-                            \"avatar_url\": \"https://example.com/example.jpg\",\n-                            \"updated_at\": now.isoformat(),\n-                        }\n-                    ),\n-                    200,\n+                self.mock_oauth_server.register_route_handler(*user_request)(\n+                    (\n+                        json.dumps(\n+                            {\n+                                \"id\": 1,\n+                                \"login\": \"octocat\",\n+                                \"name\": \"monalisa octocat\",\n+                                \"email\": \"octocat+2@example.com\",\n+                                \"avatar_url\": \"https://example.com/example.jpg\",\n+                                \"updated_at\": now.isoformat(),\n+                            }\n+                        ),\n+                        200,\n+                    )\n+                )\n+                self.http_con_request(\n+                    http_con,\n+                    {\"state\": state_token, \"code\": \"abc123\"},\n+                    path=\"callback\",\n                 )\n-            )\n-            self.http_con_request(\n-                http_con,\n-                {\"state\": state_token, \"code\": \"abc123\"},\n-                path=\"callback\",\n-            )\n \n-            same_identity = await self.con.query(\n-                \"\"\"\n-                SELECT ext::auth::Identity\n-                FILTER .subject = '1'\n-                AND .issuer = 'https://github.com'\n+                same_identity = await self.con.query(\n+                    \"\"\"\n+                    SELECT ext::auth::Identity\n+                    FILTER .subject = '1'\n+                    AND .issuer = 'https://github.com'\n+                    \"\"\"\n+                )\n+                self.assertEqual(len(same_identity), 1)\n+                self.assertEqual(identity[0].id, same_identity[0].id)\n+        finally:\n+            await self.con.query(\n                 \"\"\"\n+                CONFIGURE CURRENT DATABASE\n+                RESET ext::auth::WebhookConfig\n+                filter .url = <str>$url;\n+                \"\"\",\n+                url=webhook_url,\n             )\n-            self.assertEqual(len(same_identity), 1)\n-            self.assertEqual(identity[0].id, same_identity[0].id)\n \n     async def test_http_auth_ext_github_callback_failure_01(self):\n         with self.http_con() as http_con:\n",
    "problem_statement": "For OAuth the webhook event `IdentityCreated` isn't fired by Gel Auth extension\n- Gel Version: `6.4+4e5cdad`\n- Gel CLI Version: `7.3.0+13073b3`\n- OS Version: Windows 11 Pro 24H2 build `26100.4061` (with Gel running in WSL2)\n\nSteps to Reproduce:\n\n1. Setup OAuth Provider\n2. Setup Webhook URL with both the `IdentityCreated` and `IdentityAuthenticated` events enabled\n3. Setup proper redirect urls\n4. Sign up using OAuth provider\n5. Only `IdentityAuthenticated` is received, expected to also get the `IdentityCreated` event.\n",
    "environment_setup_commit": "4a5f17379884d7a54e6fee20c1d9af2839a8d8fa",
    "pr_url": "https://github.com/geldata/gel/pull/8721",
    "issue_url": "https://github.com/geldata/gel/issues/8716",
    "issue_numbers": [
        "8716"
    ]
}