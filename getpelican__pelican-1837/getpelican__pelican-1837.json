{
    "instance_id": "getpelican__pelican-1837",
    "patch": "diff --git a/pelican/readers.py b/pelican/readers.py\nindex 2e51c4ff5..7a5f2ee27 100644\n--- a/pelican/readers.py\n+++ b/pelican/readers.py\n@@ -18,18 +18,14 @@\n from pelican import signals\n from pelican.cache import FileStampDataCacher\n from pelican.contents import Author, Category, Page, Tag\n-from pelican.utils import SafeDatetime, get_date, pelican_open, posixize_path\n+from pelican.utils import SafeDatetime, escape_html, get_date, pelican_open, \\\n+    posixize_path\n \n try:\n     from markdown import Markdown\n except ImportError:\n     Markdown = False  # NOQA\n \n-try:\n-    from html import escape\n-except ImportError:\n-    from cgi import escape\n-\n # Metadata processors have no way to discard an unwanted value, so we have\n # them return this value instead to signal that it should be discarded later.\n # This means that _filter_discardable_metadata() must be called on processed\n@@ -354,7 +350,7 @@ def handle_endtag(self, tag):\n                 self._in_body = False\n                 self._in_top_level = True\n             elif self._in_body:\n-                self._data_buffer += '</{}>'.format(escape(tag))\n+                self._data_buffer += '</{}>'.format(escape_html(tag))\n \n         def handle_startendtag(self, tag, attrs):\n             if tag == 'meta' and self._in_head:\n@@ -375,11 +371,16 @@ def handle_charref(self, data):\n             self._data_buffer += '&#{};'.format(data)\n \n         def build_tag(self, tag, attrs, close_tag):\n-            result = '<{}'.format(escape(tag))\n+            result = '<{}'.format(escape_html(tag))\n             for k, v in attrs:\n-                result += ' ' + escape(k)\n+                result += ' ' + escape_html(k)\n                 if v is not None:\n-                    result += '=\"{}\"'.format(escape(v))\n+                    # If the attribute value contains a double quote, surround\n+                    # with single quotes, otherwise use double quotes.\n+                    if '\"' in v:\n+                        result += \"='{}'\".format(escape_html(v, quote=False))\n+                    else:\n+                        result += '=\"{}\"'.format(escape_html(v, quote=False))\n             if close_tag:\n                 return result + ' />'\n             return result + '>'\ndiff --git a/pelican/utils.py b/pelican/utils.py\nindex cc9eb405c..1422a979a 100644\n--- a/pelican/utils.py\n+++ b/pelican/utils.py\n@@ -28,6 +28,11 @@\n from six.moves import html_entities\n from six.moves.html_parser import HTMLParser\n \n+try:\n+    from html import escape\n+except ImportError:\n+    from cgi import escape\n+\n logger = logging.getLogger(__name__)\n \n \n@@ -548,6 +553,14 @@ def truncate_html_words(s, num, end_text='...'):\n     return out\n \n \n+def escape_html(text, quote=True):\n+    \"\"\"Escape '&', '<' and '>' to HTML-safe sequences.\n+\n+    In Python 2 this uses cgi.escape and in Python 3 this uses html.escape. We\n+    wrap here to ensure the quote argument has an identical default.\"\"\"\n+    return escape(text, quote=quote)\n+\n+\n def process_translations(content_list, order_by=None):\n     \"\"\" Finds translation and returns them.\n \n",
    "repo": "getpelican/pelican",
    "base_commit": "661ee49edae0bfbb0641f4f9bc223e6f6feb50f2",
    "hints_text": "",
    "created_at": "2015-10-04T18:35:02Z",
    "test_patch": "diff --git a/pelican/tests/content/article_with_attributes_containing_double_quotes.html b/pelican/tests/content/article_with_attributes_containing_double_quotes.html\nnew file mode 100644\nindex 000000000..7daa58015\n--- /dev/null\n+++ b/pelican/tests/content/article_with_attributes_containing_double_quotes.html\n@@ -0,0 +1,11 @@\n+<html>\n+    <head>\n+    </head>\n+    <body>\n+        Ensure that if an attribute value contains a double quote, it is\n+        surrounded with single quotes, otherwise with double quotes.\n+        <span data-test=\"'single quoted string'\">Span content</span>\n+        <span data-test='\"double quoted string\"'>Span content</span>\n+        <span data-test=\"string without quotes\">Span content</span>\n+    </body>\n+</html>\ndiff --git a/pelican/tests/test_cache.py b/pelican/tests/test_cache.py\nindex 006e421b6..3da3f7897 100644\n--- a/pelican/tests/test_cache.py\n+++ b/pelican/tests/test_cache.py\n@@ -61,7 +61,7 @@ def test_article_object_caching(self):\n         - article_with_null_attributes.html\n         - 2012-11-30_md_w_filename_meta#foo-bar.md\n         \"\"\"\n-        self.assertEqual(generator.readers.read_file.call_count, 3)\n+        self.assertEqual(generator.readers.read_file.call_count, 4)\n \n     @unittest.skipUnless(MagicMock, 'Needs Mock module')\n     def test_article_reader_content_caching(self):\ndiff --git a/pelican/tests/test_readers.py b/pelican/tests/test_readers.py\nindex 5fabc470c..dc4348357 100644\n--- a/pelican/tests/test_readers.py\n+++ b/pelican/tests/test_readers.py\n@@ -587,6 +587,17 @@ def test_article_with_null_attributes(self):\n         <input name=\"test\" disabled style=\"\" />\n     ''', page.content)\n \n+    def test_article_with_attributes_containing_double_quotes(self):\n+        page = self.read_file(path='article_with_attributes_containing_' +\n+                                   'double_quotes.html')\n+        self.assertEqual('''\n+        Ensure that if an attribute value contains a double quote, it is\n+        surrounded with single quotes, otherwise with double quotes.\n+        <span data-test=\"'single quoted string'\">Span content</span>\n+        <span data-test='\"double quoted string\"'>Span content</span>\n+        <span data-test=\"string without quotes\">Span content</span>\n+    ''', page.content)\n+\n     def test_article_metadata_key_lowercase(self):\n         # Keys of metadata should be lowercase.\n         page = self.read_file(path='article_with_uppercase_metadata.html')\n",
    "problem_statement": "Quote escapes improperly handled when generating HTML articles\nSay if I want to include JSON dataset in an HTML element say\n\n``` html\n<section id=\"my-section\" data-my-data='{\"myJSON\": \"object\"}'> ... <\\section>\n```\n\nthe output will be\n\n``` html\n<section id=\"my-section\" data-my-data=\"{\"myJSON\": \"object\"}\"> ... <\\section>\n```\n\nwhich is terrible. Note the significant change from single to double quotes.\n\nUnder most circumstances this isn't a problem, since reversing the quotes  (double quotes surrounding single quotes) will retain the orders, but that is not a valid JSON-object. It keys and strings _have_ to be surrounded by double quotes.\n\nI tried looking through the code base to fix it my self. But I have no idea where the transition happens.\n\nBest regards,\n\n",
    "environment_setup_commit": "661ee49edae0bfbb0641f4f9bc223e6f6feb50f2",
    "pr_url": "https://github.com/getpelican/pelican/pull/1837",
    "issue_url": "https://github.com/getpelican/pelican/issues/1260",
    "issue_numbers": [
        "1260"
    ]
}