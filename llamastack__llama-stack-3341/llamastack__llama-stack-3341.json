{
    "instance_id": "llamastack__llama-stack-3341",
    "patch": "diff --git a/llama_stack/core/distribution.py b/llama_stack/core/distribution.py\nindex f44967aaf5..0ebb847af4 100644\n--- a/llama_stack/core/distribution.py\n+++ b/llama_stack/core/distribution.py\n@@ -243,6 +243,7 @@ def get_external_providers_from_module(\n                     spec = module.get_provider_spec()\n                 else:\n                     # pass in a partially filled out provider spec to satisfy the registry -- knowing we will be overwriting it later upon build and run\n+                    # in the case we are building we CANNOT import this module of course because it has not been installed.\n                     spec = ProviderSpec(\n                         api=Api(provider_api),\n                         provider_type=provider.provider_type,\n@@ -251,9 +252,20 @@ def get_external_providers_from_module(\n                         config_class=\"\",\n                     )\n                 provider_type = provider.provider_type\n-                # in the case we are building we CANNOT import this module of course because it has not been installed.\n-                # return a partially filled out spec that the build script will populate.\n-                registry[Api(provider_api)][provider_type] = spec\n+                if isinstance(spec, list):\n+                    # optionally allow people to pass inline and remote provider specs as a returned list.\n+                    # with the old method, users could pass in directories of specs using overlapping code\n+                    # we want to ensure we preserve that flexibility in this method.\n+                    logger.info(\n+                        f\"Detected a list of external provider specs from {provider.module} adding all to the registry\"\n+                    )\n+                    for provider_spec in spec:\n+                        if provider_spec.provider_type != provider.provider_type:\n+                            continue\n+                        logger.info(f\"Adding {provider.provider_type} to registry\")\n+                        registry[Api(provider_api)][provider.provider_type] = provider_spec\n+                else:\n+                    registry[Api(provider_api)][provider_type] = spec\n             except ModuleNotFoundError as exc:\n                 raise ValueError(\n                     \"get_provider_spec not found. If specifying an external provider via `module` in the Provider spec, the Provider must have the `provider.get_provider_spec` module available\"\n",
    "repo": "llamastack/llama-stack",
    "base_commit": "426cac078b75e6f52dff2c16240989fd924a1f11",
    "hints_text": "thanks. I think this makes sense and I can take this on!",
    "created_at": "2025-09-05T15:24:44Z",
    "test_patch": "diff --git a/tests/unit/distribution/test_distribution.py b/tests/unit/distribution/test_distribution.py\nindex f24de06440..91ea6be6f1 100644\n--- a/tests/unit/distribution/test_distribution.py\n+++ b/tests/unit/distribution/test_distribution.py\n@@ -390,3 +390,467 @@ def test_external_provider_from_module_building(self, mock_providers):\n         assert provider.is_external is True\n         # config_class is empty string in partial spec\n         assert provider.config_class == \"\"\n+\n+\n+class TestGetExternalProvidersFromModule:\n+    \"\"\"Test suite for installing external providers from module.\"\"\"\n+\n+    def test_stackrunconfig_provider_without_module(self, mock_providers):\n+        \"\"\"Test that providers without module attribute are skipped.\"\"\"\n+        from llama_stack.core.datatypes import Provider, StackRunConfig\n+        from llama_stack.core.distribution import get_external_providers_from_module\n+\n+        import_module_side_effect = make_import_module_side_effect()\n+\n+        with patch(\"importlib.import_module\", side_effect=import_module_side_effect):\n+            config = StackRunConfig(\n+                image_name=\"test_image\",\n+                providers={\n+                    \"inference\": [\n+                        Provider(\n+                            provider_id=\"no_module\",\n+                            provider_type=\"no_module\",\n+                            config={},\n+                        )\n+                    ]\n+                },\n+            )\n+            registry = {Api.inference: {}}\n+            result = get_external_providers_from_module(registry, config, building=False)\n+            # Should not add anything to registry\n+            assert len(result[Api.inference]) == 0\n+\n+    def test_stackrunconfig_with_version_spec(self, mock_providers):\n+        \"\"\"Test provider with module containing version spec (e.g., package==1.0.0).\"\"\"\n+        from types import SimpleNamespace\n+\n+        from llama_stack.core.datatypes import Provider, StackRunConfig\n+        from llama_stack.core.distribution import get_external_providers_from_module\n+        from llama_stack.providers.datatypes import ProviderSpec\n+\n+        fake_spec = ProviderSpec(\n+            api=Api.inference,\n+            provider_type=\"versioned_test\",\n+            config_class=\"versioned_test.config.VersionedTestConfig\",\n+            module=\"versioned_test==1.0.0\",\n+        )\n+        fake_module = SimpleNamespace(get_provider_spec=lambda: fake_spec)\n+\n+        def import_side_effect(name):\n+            if name == \"versioned_test.provider\":\n+                return fake_module\n+            raise ModuleNotFoundError(name)\n+\n+        with patch(\"importlib.import_module\", side_effect=import_side_effect):\n+            config = StackRunConfig(\n+                image_name=\"test_image\",\n+                providers={\n+                    \"inference\": [\n+                        Provider(\n+                            provider_id=\"versioned\",\n+                            provider_type=\"versioned_test\",\n+                            config={},\n+                            module=\"versioned_test==1.0.0\",\n+                        )\n+                    ]\n+                },\n+            )\n+            registry = {Api.inference: {}}\n+            result = get_external_providers_from_module(registry, config, building=False)\n+            assert \"versioned_test\" in result[Api.inference]\n+            assert result[Api.inference][\"versioned_test\"].module == \"versioned_test==1.0.0\"\n+\n+    def test_buildconfig_does_not_import_module(self, mock_providers):\n+        \"\"\"Test that BuildConfig does not import the module (building=True).\"\"\"\n+        from llama_stack.core.datatypes import BuildConfig, BuildProvider, DistributionSpec\n+        from llama_stack.core.distribution import get_external_providers_from_module\n+\n+        build_config = BuildConfig(\n+            version=2,\n+            image_type=\"container\",\n+            image_name=\"test_image\",\n+            distribution_spec=DistributionSpec(\n+                description=\"test\",\n+                providers={\n+                    \"inference\": [\n+                        BuildProvider(\n+                            provider_type=\"build_test\",\n+                            module=\"build_test==1.0.0\",\n+                        )\n+                    ]\n+                },\n+            ),\n+        )\n+\n+        # Should not call import_module at all when building\n+        with patch(\"importlib.import_module\") as mock_import:\n+            registry = {Api.inference: {}}\n+            result = get_external_providers_from_module(registry, build_config, building=True)\n+\n+            # Verify module was NOT imported\n+            mock_import.assert_not_called()\n+\n+            # Verify partial spec was created\n+            assert \"build_test\" in result[Api.inference]\n+            provider = result[Api.inference][\"build_test\"]\n+            assert provider.module == \"build_test==1.0.0\"\n+            assert provider.is_external is True\n+            assert provider.config_class == \"\"\n+            assert provider.api == Api.inference\n+\n+    def test_buildconfig_multiple_providers(self, mock_providers):\n+        \"\"\"Test BuildConfig with multiple providers for the same API.\"\"\"\n+        from llama_stack.core.datatypes import BuildConfig, BuildProvider, DistributionSpec\n+        from llama_stack.core.distribution import get_external_providers_from_module\n+\n+        build_config = BuildConfig(\n+            version=2,\n+            image_type=\"container\",\n+            image_name=\"test_image\",\n+            distribution_spec=DistributionSpec(\n+                description=\"test\",\n+                providers={\n+                    \"inference\": [\n+                        BuildProvider(provider_type=\"provider1\", module=\"provider1\"),\n+                        BuildProvider(provider_type=\"provider2\", module=\"provider2\"),\n+                    ]\n+                },\n+            ),\n+        )\n+\n+        with patch(\"importlib.import_module\") as mock_import:\n+            registry = {Api.inference: {}}\n+            result = get_external_providers_from_module(registry, build_config, building=True)\n+\n+            mock_import.assert_not_called()\n+            assert \"provider1\" in result[Api.inference]\n+            assert \"provider2\" in result[Api.inference]\n+\n+    def test_distributionspec_does_not_import_module(self, mock_providers):\n+        \"\"\"Test that DistributionSpec does not import the module (building=True).\"\"\"\n+        from llama_stack.core.datatypes import BuildProvider, DistributionSpec\n+        from llama_stack.core.distribution import get_external_providers_from_module\n+\n+        dist_spec = DistributionSpec(\n+            description=\"test distribution\",\n+            providers={\n+                \"inference\": [\n+                    BuildProvider(\n+                        provider_type=\"dist_test\",\n+                        module=\"dist_test==2.0.0\",\n+                    )\n+                ]\n+            },\n+        )\n+\n+        # Should not call import_module at all when building\n+        with patch(\"importlib.import_module\") as mock_import:\n+            registry = {Api.inference: {}}\n+            result = get_external_providers_from_module(registry, dist_spec, building=True)\n+\n+            # Verify module was NOT imported\n+            mock_import.assert_not_called()\n+\n+            # Verify partial spec was created\n+            assert \"dist_test\" in result[Api.inference]\n+            provider = result[Api.inference][\"dist_test\"]\n+            assert provider.module == \"dist_test==2.0.0\"\n+            assert provider.is_external is True\n+            assert provider.config_class == \"\"\n+\n+    def test_list_return_from_get_provider_spec(self, mock_providers):\n+        \"\"\"Test when get_provider_spec returns a list of specs.\"\"\"\n+        from types import SimpleNamespace\n+\n+        from llama_stack.core.datatypes import Provider, StackRunConfig\n+        from llama_stack.core.distribution import get_external_providers_from_module\n+        from llama_stack.providers.datatypes import ProviderSpec\n+\n+        spec1 = ProviderSpec(\n+            api=Api.inference,\n+            provider_type=\"list_test\",\n+            config_class=\"list_test.config.Config1\",\n+            module=\"list_test\",\n+        )\n+        spec2 = ProviderSpec(\n+            api=Api.inference,\n+            provider_type=\"list_test_remote\",\n+            config_class=\"list_test.config.Config2\",\n+            module=\"list_test\",\n+        )\n+\n+        fake_module = SimpleNamespace(get_provider_spec=lambda: [spec1, spec2])\n+\n+        def import_side_effect(name):\n+            if name == \"list_test.provider\":\n+                return fake_module\n+            raise ModuleNotFoundError(name)\n+\n+        with patch(\"importlib.import_module\", side_effect=import_side_effect):\n+            config = StackRunConfig(\n+                image_name=\"test_image\",\n+                providers={\n+                    \"inference\": [\n+                        Provider(\n+                            provider_id=\"list_test\",\n+                            provider_type=\"list_test\",\n+                            config={},\n+                            module=\"list_test\",\n+                        )\n+                    ]\n+                },\n+            )\n+            registry = {Api.inference: {}}\n+            result = get_external_providers_from_module(registry, config, building=False)\n+\n+            # Only the matching provider_type should be added\n+            assert \"list_test\" in result[Api.inference]\n+            assert result[Api.inference][\"list_test\"].config_class == \"list_test.config.Config1\"\n+\n+    def test_list_return_filters_by_provider_type(self, mock_providers):\n+        \"\"\"Test that list return filters specs by provider_type.\"\"\"\n+        from types import SimpleNamespace\n+\n+        from llama_stack.core.datatypes import Provider, StackRunConfig\n+        from llama_stack.core.distribution import get_external_providers_from_module\n+        from llama_stack.providers.datatypes import ProviderSpec\n+\n+        spec1 = ProviderSpec(\n+            api=Api.inference,\n+            provider_type=\"wanted\",\n+            config_class=\"test.Config1\",\n+            module=\"test\",\n+        )\n+        spec2 = ProviderSpec(\n+            api=Api.inference,\n+            provider_type=\"unwanted\",\n+            config_class=\"test.Config2\",\n+            module=\"test\",\n+        )\n+\n+        fake_module = SimpleNamespace(get_provider_spec=lambda: [spec1, spec2])\n+\n+        def import_side_effect(name):\n+            if name == \"test.provider\":\n+                return fake_module\n+            raise ModuleNotFoundError(name)\n+\n+        with patch(\"importlib.import_module\", side_effect=import_side_effect):\n+            config = StackRunConfig(\n+                image_name=\"test_image\",\n+                providers={\n+                    \"inference\": [\n+                        Provider(\n+                            provider_id=\"wanted\",\n+                            provider_type=\"wanted\",\n+                            config={},\n+                            module=\"test\",\n+                        )\n+                    ]\n+                },\n+            )\n+            registry = {Api.inference: {}}\n+            result = get_external_providers_from_module(registry, config, building=False)\n+\n+            # Only the matching provider_type should be added\n+            assert \"wanted\" in result[Api.inference]\n+            assert \"unwanted\" not in result[Api.inference]\n+\n+    def test_list_return_adds_multiple_provider_types(self, mock_providers):\n+        \"\"\"Test that list return adds multiple different provider_types when config requests them.\"\"\"\n+        from types import SimpleNamespace\n+\n+        from llama_stack.core.datatypes import Provider, StackRunConfig\n+        from llama_stack.core.distribution import get_external_providers_from_module\n+        from llama_stack.providers.datatypes import ProviderSpec\n+\n+        # Module returns both inline and remote variants\n+        spec1 = ProviderSpec(\n+            api=Api.inference,\n+            provider_type=\"remote::ollama\",\n+            config_class=\"test.RemoteConfig\",\n+            module=\"test\",\n+        )\n+        spec2 = ProviderSpec(\n+            api=Api.inference,\n+            provider_type=\"inline::ollama\",\n+            config_class=\"test.InlineConfig\",\n+            module=\"test\",\n+        )\n+\n+        fake_module = SimpleNamespace(get_provider_spec=lambda: [spec1, spec2])\n+\n+        def import_side_effect(name):\n+            if name == \"test.provider\":\n+                return fake_module\n+            raise ModuleNotFoundError(name)\n+\n+        with patch(\"importlib.import_module\", side_effect=import_side_effect):\n+            config = StackRunConfig(\n+                image_name=\"test_image\",\n+                providers={\n+                    \"inference\": [\n+                        Provider(\n+                            provider_id=\"remote_ollama\",\n+                            provider_type=\"remote::ollama\",\n+                            config={},\n+                            module=\"test\",\n+                        ),\n+                        Provider(\n+                            provider_id=\"inline_ollama\",\n+                            provider_type=\"inline::ollama\",\n+                            config={},\n+                            module=\"test\",\n+                        ),\n+                    ]\n+                },\n+            )\n+            registry = {Api.inference: {}}\n+            result = get_external_providers_from_module(registry, config, building=False)\n+\n+            # Both provider types should be added to registry\n+            assert \"remote::ollama\" in result[Api.inference]\n+            assert \"inline::ollama\" in result[Api.inference]\n+            assert result[Api.inference][\"remote::ollama\"].config_class == \"test.RemoteConfig\"\n+            assert result[Api.inference][\"inline::ollama\"].config_class == \"test.InlineConfig\"\n+\n+    def test_module_not_found_raises_value_error(self, mock_providers):\n+        \"\"\"Test that ModuleNotFoundError raises ValueError with helpful message.\"\"\"\n+        from llama_stack.core.datatypes import Provider, StackRunConfig\n+        from llama_stack.core.distribution import get_external_providers_from_module\n+\n+        def import_side_effect(name):\n+            if name == \"missing_module.provider\":\n+                raise ModuleNotFoundError(name)\n+            raise ModuleNotFoundError(name)\n+\n+        with patch(\"importlib.import_module\", side_effect=import_side_effect):\n+            config = StackRunConfig(\n+                image_name=\"test_image\",\n+                providers={\n+                    \"inference\": [\n+                        Provider(\n+                            provider_id=\"missing\",\n+                            provider_type=\"missing\",\n+                            config={},\n+                            module=\"missing_module\",\n+                        )\n+                    ]\n+                },\n+            )\n+            registry = {Api.inference: {}}\n+\n+            with pytest.raises(ValueError) as exc_info:\n+                get_external_providers_from_module(registry, config, building=False)\n+\n+            assert \"get_provider_spec not found\" in str(exc_info.value)\n+\n+    def test_generic_exception_is_raised(self, mock_providers):\n+        \"\"\"Test that generic exceptions are properly raised.\"\"\"\n+        from types import SimpleNamespace\n+\n+        from llama_stack.core.datatypes import Provider, StackRunConfig\n+        from llama_stack.core.distribution import get_external_providers_from_module\n+\n+        def bad_spec():\n+            raise RuntimeError(\"Something went wrong\")\n+\n+        fake_module = SimpleNamespace(get_provider_spec=bad_spec)\n+\n+        def import_side_effect(name):\n+            if name == \"error_module.provider\":\n+                return fake_module\n+            raise ModuleNotFoundError(name)\n+\n+        with patch(\"importlib.import_module\", side_effect=import_side_effect):\n+            config = StackRunConfig(\n+                image_name=\"test_image\",\n+                providers={\n+                    \"inference\": [\n+                        Provider(\n+                            provider_id=\"error\",\n+                            provider_type=\"error\",\n+                            config={},\n+                            module=\"error_module\",\n+                        )\n+                    ]\n+                },\n+            )\n+            registry = {Api.inference: {}}\n+\n+            with pytest.raises(RuntimeError) as exc_info:\n+                get_external_providers_from_module(registry, config, building=False)\n+\n+            assert \"Something went wrong\" in str(exc_info.value)\n+\n+    def test_empty_provider_list(self, mock_providers):\n+        \"\"\"Test with empty provider list.\"\"\"\n+        from llama_stack.core.datatypes import StackRunConfig\n+        from llama_stack.core.distribution import get_external_providers_from_module\n+\n+        config = StackRunConfig(\n+            image_name=\"test_image\",\n+            providers={},\n+        )\n+        registry = {Api.inference: {}}\n+        result = get_external_providers_from_module(registry, config, building=False)\n+\n+        # Should return registry unchanged\n+        assert result == registry\n+        assert len(result[Api.inference]) == 0\n+\n+    def test_multiple_apis_with_providers(self, mock_providers):\n+        \"\"\"Test multiple APIs with providers.\"\"\"\n+        from types import SimpleNamespace\n+\n+        from llama_stack.core.datatypes import Provider, StackRunConfig\n+        from llama_stack.core.distribution import get_external_providers_from_module\n+        from llama_stack.providers.datatypes import ProviderSpec\n+\n+        inference_spec = ProviderSpec(\n+            api=Api.inference,\n+            provider_type=\"inf_test\",\n+            config_class=\"inf.Config\",\n+            module=\"inf_test\",\n+        )\n+        safety_spec = ProviderSpec(\n+            api=Api.safety,\n+            provider_type=\"safe_test\",\n+            config_class=\"safe.Config\",\n+            module=\"safe_test\",\n+        )\n+\n+        def import_side_effect(name):\n+            if name == \"inf_test.provider\":\n+                return SimpleNamespace(get_provider_spec=lambda: inference_spec)\n+            elif name == \"safe_test.provider\":\n+                return SimpleNamespace(get_provider_spec=lambda: safety_spec)\n+            raise ModuleNotFoundError(name)\n+\n+        with patch(\"importlib.import_module\", side_effect=import_side_effect):\n+            config = StackRunConfig(\n+                image_name=\"test_image\",\n+                providers={\n+                    \"inference\": [\n+                        Provider(\n+                            provider_id=\"inf\",\n+                            provider_type=\"inf_test\",\n+                            config={},\n+                            module=\"inf_test\",\n+                        )\n+                    ],\n+                    \"safety\": [\n+                        Provider(\n+                            provider_id=\"safe\",\n+                            provider_type=\"safe_test\",\n+                            config={},\n+                            module=\"safe_test\",\n+                        )\n+                    ],\n+                },\n+            )\n+            registry = {Api.inference: {}, Api.safety: {}}\n+            result = get_external_providers_from_module(registry, config, building=False)\n+\n+            assert \"inf_test\" in result[Api.inference]\n+            assert \"safe_test\" in result[Api.safety]\n",
    "problem_statement": "Support both inline and remote implementations within a single provider\n### ðŸ¤” What is the technical debt you think should be addressed?\n\nCurrently, the external provider system in LlamaStack requires separate modules for inline and remote implementations of the same provider. When using the `module:` configuration approach, `get_external_providers_from_module` in distribution.py expects a single provider `spec` per module, while the directory-based approach (`get_external_providers_from_dir`) can process both inline and remote implementations together.\n\nThis limitation forces developers to create two distinct packages (e.g., `provider_name.inline` and `provider_name.remote`) with separate `get_provider_spec` functions, even when both implementations logically belong to the same provider and could share common code or resources.\n\n### ðŸ’¡ What is the benefit of addressing this technical debt?\n\nAllowing a single module to provide both inline and remote implementations would:\n\n- Align the module-based approach capabilities with the directory-based approach for consistency\n- Improve developer experience by allowing more flexible provider organization\n- Simplify provider package structure and distribution\n\n\n### Other thoughts\n\nThis _could_ be achieved by maybe supporting dict for `module.get_provider_spec()` with `inline` and `remote` keys. (just a thought)\n",
    "environment_setup_commit": "426cac078b75e6f52dff2c16240989fd924a1f11",
    "pr_url": "https://github.com/llamastack/llama-stack/pull/3341",
    "issue_url": "https://github.com/llamastack/llama-stack/issues/3226",
    "issue_numbers": [
        "3226"
    ]
}