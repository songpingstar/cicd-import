{
    "instance_id": "getpelican__pelican-2196",
    "patch": "diff --git a/pelican/contents.py b/pelican/contents.py\nindex 15770fc87..e84c8296b 100644\n--- a/pelican/contents.py\n+++ b/pelican/contents.py\n@@ -11,7 +11,7 @@\n import pytz\n \n import six\n-from six.moves.urllib.parse import urlparse, urlunparse\n+from six.moves.urllib.parse import urljoin, urlparse, urlunparse\n \n from pelican import signals\n from pelican.settings import DEFAULT_CONFIG\n@@ -228,6 +228,87 @@ def get_url_setting(self, key):\n         key = key if self.in_default_lang else 'lang_%s' % key\n         return self._expand_settings(key)\n \n+    def _link_replacer(self, siteurl, m):\n+        what = m.group('what')\n+        value = urlparse(m.group('value'))\n+        path = value.path\n+        origin = m.group('path')\n+\n+        # urllib.parse.urljoin() produces `a.html` for urljoin(\"..\", \"a.html\")\n+        # so if RELATIVE_URLS are enabled, we fall back to os.path.join() to\n+        # properly get `../a.html`. However, os.path.join() produces\n+        # `baz/http://foo/bar.html` for join(\"baz\", \"http://foo/bar.html\")\n+        # instead of correct \"http://foo/bar.html\", so one has to pick a side\n+        # as there is no silver bullet.\n+        if self.settings['RELATIVE_URLS']:\n+            joiner = os.path.join\n+        else:\n+            joiner = urljoin\n+\n+            # However, it's not *that* simple: urljoin(\"blog\", \"index.html\")\n+            # produces just `index.html` instead of `blog/index.html` (unlike\n+            # os.path.join()), so in order to get a correct answer one needs to\n+            # append a trailing slash to siteurl in that case. This also makes\n+            # the new behavior fully compatible with Pelican 3.7.1.\n+            if not siteurl.endswith('/'):\n+                siteurl += '/'\n+\n+        # XXX Put this in a different location.\n+        if what in {'filename', 'attach'}:\n+            if path.startswith('/'):\n+                path = path[1:]\n+            else:\n+                # relative to the source path of this content\n+                path = self.get_relative_source_path(\n+                    os.path.join(self.relative_dir, path)\n+                )\n+\n+            if path not in self._context['filenames']:\n+                unquoted_path = path.replace('%20', ' ')\n+\n+                if unquoted_path in self._context['filenames']:\n+                    path = unquoted_path\n+\n+            linked_content = self._context['filenames'].get(path)\n+            if linked_content:\n+                if what == 'attach':\n+                    if isinstance(linked_content, Static):\n+                        linked_content.attach_to(self)\n+                    else:\n+                        logger.warning(\n+                            \"%s used {attach} link syntax on a \"\n+                            \"non-static file. Use {filename} instead.\",\n+                            self.get_relative_source_path())\n+                origin = joiner(siteurl, linked_content.url)\n+                origin = origin.replace('\\\\', '/')  # for Windows paths.\n+            else:\n+                logger.warning(\n+                    \"Unable to find '%s', skipping url replacement.\",\n+                    value.geturl(), extra={\n+                        'limit_msg': (\"Other resources were not found \"\n+                                      \"and their urls not replaced\")})\n+        elif what == 'category':\n+            origin = joiner(siteurl, Category(path, self.settings).url)\n+        elif what == 'tag':\n+            origin = joiner(siteurl, Tag(path, self.settings).url)\n+        elif what == 'index':\n+            origin = joiner(siteurl, self.settings['INDEX_SAVE_AS'])\n+        elif what == 'author':\n+            origin = joiner(siteurl, Author(path, self.settings).url)\n+        else:\n+            logger.warning(\n+                \"Replacement Indicator '%s' not recognized, \"\n+                \"skipping replacement\",\n+                what)\n+\n+        # keep all other parts, such as query, fragment, etc.\n+        parts = list(value)\n+        parts[2] = origin\n+        origin = urlunparse(parts)\n+\n+        return ''.join((m.group('markup'), m.group('quote'), origin,\n+                        m.group('quote')))\n+\n     def _update_content(self, content, siteurl):\n         \"\"\"Update the content attribute.\n \n@@ -251,69 +332,7 @@ def _update_content(self, content, siteurl):\n             \\2\"\"\".format(instrasite_link_regex)\n         hrefs = re.compile(regex, re.X)\n \n-        def replacer(m):\n-            what = m.group('what')\n-            value = urlparse(m.group('value'))\n-            path = value.path\n-            origin = m.group('path')\n-\n-            # XXX Put this in a different location.\n-            if what in {'filename', 'attach'}:\n-                if path.startswith('/'):\n-                    path = path[1:]\n-                else:\n-                    # relative to the source path of this content\n-                    path = self.get_relative_source_path(\n-                        os.path.join(self.relative_dir, path)\n-                    )\n-\n-                if path not in self._context['filenames']:\n-                    unquoted_path = path.replace('%20', ' ')\n-\n-                    if unquoted_path in self._context['filenames']:\n-                        path = unquoted_path\n-\n-                linked_content = self._context['filenames'].get(path)\n-                if linked_content:\n-                    if what == 'attach':\n-                        if isinstance(linked_content, Static):\n-                            linked_content.attach_to(self)\n-                        else:\n-                            logger.warning(\n-                                \"%s used {attach} link syntax on a \"\n-                                \"non-static file. Use {filename} instead.\",\n-                                self.get_relative_source_path())\n-                    origin = '/'.join((siteurl, linked_content.url))\n-                    origin = origin.replace('\\\\', '/')  # for Windows paths.\n-                else:\n-                    logger.warning(\n-                        \"Unable to find '%s', skipping url replacement.\",\n-                        value.geturl(), extra={\n-                            'limit_msg': (\"Other resources were not found \"\n-                                          \"and their urls not replaced\")})\n-            elif what == 'category':\n-                origin = '/'.join((siteurl, Category(path, self.settings).url))\n-            elif what == 'tag':\n-                origin = '/'.join((siteurl, Tag(path, self.settings).url))\n-            elif what == 'index':\n-                origin = '/'.join((siteurl, self.settings['INDEX_SAVE_AS']))\n-            elif what == 'author':\n-                origin = '/'.join((siteurl, Author(path, self.settings).url))\n-            else:\n-                logger.warning(\n-                    \"Replacement Indicator '%s' not recognized, \"\n-                    \"skipping replacement\",\n-                    what)\n-\n-            # keep all other parts, such as query, fragment, etc.\n-            parts = list(value)\n-            parts[2] = origin\n-            origin = urlunparse(parts)\n-\n-            return ''.join((m.group('markup'), m.group('quote'), origin,\n-                            m.group('quote')))\n-\n-        return hrefs.sub(replacer, content)\n+        return hrefs.sub(lambda m: self._link_replacer(siteurl, m), content)\n \n     def get_siteurl(self):\n         return self._context.get('localsiteurl', '')\n",
    "repo": "getpelican/pelican",
    "base_commit": "56a483475b0a42bd13cf114248c9141c9051ed84",
    "hints_text": "",
    "created_at": "2017-08-07T16:29:53Z",
    "test_patch": "diff --git a/pelican/tests/test_contents.py b/pelican/tests/test_contents.py\nindex d028c7a1a..04c82f612 100644\n--- a/pelican/tests/test_contents.py\n+++ b/pelican/tests/test_contents.py\n@@ -397,6 +397,54 @@ def test_intrasite_link_more(self):\n             '</blockquote>'\n         )\n \n+    def test_intrasite_link_absolute(self):\n+        \"\"\"Test that absolute URLs are merged properly.\"\"\"\n+\n+        args = self.page_kwargs.copy()\n+        args['settings'] = get_settings(\n+            STATIC_URL='http://static.cool.site/{path}',\n+            ARTICLE_URL='http://blog.cool.site/{slug}.html')\n+        args['source_path'] = 'content'\n+        args['context']['filenames'] = {\n+            'images/poster.jpg': Static('',\n+                                        settings=args['settings'],\n+                                        source_path='images/poster.jpg'),\n+            'article.rst': Article('',\n+                                   settings=args['settings'],\n+                                   metadata={'slug': 'article',\n+                                             'title': 'Article'})\n+        }\n+\n+        # Article link will go to blog\n+        args['content'] = (\n+            '<a href=\"{filename}article.rst\">Article</a>'\n+        )\n+        content = Page(**args).get_content('http://cool.site')\n+        self.assertEqual(\n+            content,\n+            '<a href=\"http://blog.cool.site/article.html\">Article</a>'\n+        )\n+\n+        # Page link will go to the main site\n+        args['content'] = (\n+            '<a href=\"{index}\">Index</a>'\n+        )\n+        content = Page(**args).get_content('http://cool.site')\n+        self.assertEqual(\n+            content,\n+            '<a href=\"http://cool.site/index.html\">Index</a>'\n+        )\n+\n+        # Image link will go to static\n+        args['content'] = (\n+            '<img src=\"{filename}/images/poster.jpg\"/>'\n+        )\n+        content = Page(**args).get_content('http://cool.site')\n+        self.assertEqual(\n+            content,\n+            '<img src=\"http://static.cool.site/images/poster.jpg\"/>'\n+        )\n+\n     def test_intrasite_link_markdown_spaces(self):\n         # Markdown introduces %20 instead of spaces, this tests that\n         # we support markdown doing this.\n",
    "problem_statement": "{filename} issue when {{ SITEURL }} and {{ STATIC_URL }} are different absolute URLS\nI'm trying to build a blog where {{ SITEURL }} and {{ STATIC_URL }} differ (they are actually on two different domains); when I build my blog everything that is linked through {filename} ends up with {{ SITEURL }}{{ STATIC_URL }} as a prefix in its url.\n\nThe issue seems to be in pelican/contents.py at line 245:\n\n``` python\norigin = '/'.join((siteurl, linked_content.url))\n```\n\nI just left \"linked_content.url\" and it works just fine. This is it now:\n\n``` python\norigin = inked_content.url\n```\n\nAm I missing something?\n\n",
    "environment_setup_commit": "56a483475b0a42bd13cf114248c9141c9051ed84",
    "pr_url": "https://github.com/getpelican/pelican/pull/2196",
    "issue_url": "https://github.com/getpelican/pelican/issues/2031",
    "issue_numbers": [
        "2031"
    ]
}