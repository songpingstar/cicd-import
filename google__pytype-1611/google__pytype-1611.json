{
    "instance_id": "google__pytype-1611",
    "patch": "diff --git a/pytype/rewrite/CMakeLists.txt b/pytype/rewrite/CMakeLists.txt\nindex d5cf6f005..1285e05fe 100644\n--- a/pytype/rewrite/CMakeLists.txt\n+++ b/pytype/rewrite/CMakeLists.txt\n@@ -48,7 +48,6 @@ py_library(\n     pytype.config\n     pytype.load_pytd\n     pytype.errors.errors\n-    pytype.rewrite.abstract.abstract\n )\n \n py_library(\n@@ -105,6 +104,7 @@ py_library(\n     load_abstract.py\n   DEPS\n     pytype.load_pytd\n+    pytype.pytd.pytd\n     pytype.rewrite.abstract.abstract\n     pytype.rewrite.overlays.overlays\n )\n@@ -115,6 +115,7 @@ py_test(\n   SRCS\n     load_abstract_test.py\n   DEPS\n+    pytype.rewrite.abstract.abstract\n     pytype.rewrite.tests.test_utils\n )\n \n@@ -169,7 +170,6 @@ py_test(\n     stack_test.py\n   DEPS\n     .stack\n-    pytype.rewrite.abstract.abstract\n     pytype.rewrite.tests.test_utils\n )\n \ndiff --git a/pytype/rewrite/abstract/CMakeLists.txt b/pytype/rewrite/abstract/CMakeLists.txt\nindex becf6821a..582d9927a 100644\n--- a/pytype/rewrite/abstract/CMakeLists.txt\n+++ b/pytype/rewrite/abstract/CMakeLists.txt\n@@ -90,7 +90,6 @@ py_library(\n     instances.py\n   DEPS\n     .base\n-    .classes\n )\n \n py_test(\n@@ -100,7 +99,6 @@ py_test(\n     instances_test.py\n   DEPS\n     .base\n-    .classes\n     .instances\n     pytype.rewrite.tests.test_utils\n )\n@@ -120,7 +118,6 @@ py_test(\n   SRCS\n     internal_test.py\n   DEPS\n-    .classes\n     .internal\n     pytype.rewrite.tests.test_utils\n )\n@@ -132,7 +129,6 @@ py_library(\n     utils.py\n   DEPS\n     .base\n-    .classes\n )\n \n py_test(\n@@ -142,7 +138,6 @@ py_test(\n     utils_test.py\n   DEPS\n     .base\n-    .classes\n     .utils\n     pytype.rewrite.tests.test_utils\n )\ndiff --git a/pytype/rewrite/abstract/abstract.py b/pytype/rewrite/abstract/abstract.py\nindex 2752c9451..54841ff99 100644\n--- a/pytype/rewrite/abstract/abstract.py\n+++ b/pytype/rewrite/abstract/abstract.py\n@@ -9,8 +9,8 @@\n \n BaseValue = _base.BaseValue\n ContextType = _base.ContextType\n+PythonConstant = _base.PythonConstant\n Singleton = _base.Singleton\n-Singletons = _base.Singletons\n Union = _base.Union\n \n SimpleClass = _classes.SimpleClass\n@@ -18,7 +18,6 @@\n FrozenInstance = _classes.FrozenInstance\n InterpreterClass = _classes.InterpreterClass\n MutableInstance = _classes.MutableInstance\n-PythonConstant = _classes.PythonConstant\n \n Args = _functions.Args\n BaseFunction = _functions.BaseFunction\n@@ -34,6 +33,7 @@\n Dict = _instances.Dict\n List = _instances.List\n Set = _instances.Set\n+Tuple = _instances.Tuple\n \n ConstKeyDict = _internal.ConstKeyDict\n Splat = _internal.Splat\ndiff --git a/pytype/rewrite/abstract/base.py b/pytype/rewrite/abstract/base.py\nindex 8006630d4..7d626b3f1 100644\n--- a/pytype/rewrite/abstract/base.py\n+++ b/pytype/rewrite/abstract/base.py\n@@ -1,8 +1,7 @@\n \"\"\"Base abstract representation of Python values.\"\"\"\n \n import abc\n-import dataclasses\n-from typing import Any, Dict, Optional, Protocol, Sequence, Tuple\n+from typing import Any, Generic, Optional, Protocol, Sequence, Tuple, TypeVar\n \n from pytype import config\n from pytype import load_pytd\n@@ -12,22 +11,7 @@\n from pytype.types import types\n from typing_extensions import Self\n \n-\n-@dataclasses.dataclass(init=False)\n-class Singletons:\n-  \"\"\"Singleton abstract values.\"\"\"\n-\n-  # For readability, we give these the same name as the value they represent.\n-  # pylint: disable=invalid-name\n-  Any: 'Singleton'\n-  __build_class__: 'Singleton'\n-  Never: 'Singleton'\n-  NULL: 'Singleton'\n-  # pylint: enable=invalid-name\n-\n-  def __init__(self, ctx: 'ContextType'):\n-    for field in dataclasses.fields(self):\n-      setattr(self, field.name, Singleton(ctx, field.name))\n+_T = TypeVar('_T')\n \n \n class ContextType(Protocol):\n@@ -35,16 +19,21 @@ class ContextType(Protocol):\n   options: config.Options\n   pytd_loader: load_pytd.Loader\n \n-  singles: Singletons\n   errorlog: Any\n   abstract_converter: Any\n   abstract_loader: Any\n   pytd_converter: Any\n+  consts: Any\n \n \n class BaseValue(types.BaseValue, abc.ABC):\n   \"\"\"Base class for abstract values.\"\"\"\n \n+  # For convenience, we want the 'name' attribute to be available on all values.\n+  # Setting it as a class attribute gives subclasses the most flexibility in how\n+  # to define it.\n+  name = ''\n+\n   def __init__(self, ctx: ContextType):\n     self._ctx = ctx\n \n@@ -62,14 +51,18 @@ def _attrs(self) -> Tuple[Any, ...]:\n     `self._ctx`.\n     \"\"\"\n \n+  @property\n+  def full_name(self):\n+    return self.name\n+\n   def __eq__(self, other):\n     return self.__class__ == other.__class__ and self._attrs == other._attrs\n \n   def __hash__(self):\n     return hash((self.__class__, self._ctx) + self._attrs)\n \n-  def to_variable(self: Self) -> variables.Variable[Self]:\n-    return variables.Variable.from_value(self)\n+  def to_variable(self, name: Optional[str] = None) -> variables.Variable[Self]:\n+    return variables.Variable.from_value(self, name=name)\n \n   def get_attribute(self, name: str) -> Optional['BaseValue']:\n     del name  # unused\n@@ -92,21 +85,44 @@ def to_pytd_type_of_instance(self) -> pytd.Type:\n     return self._ctx.pytd_converter.to_pytd_type_of_instance(self)\n \n \n+class PythonConstant(BaseValue, Generic[_T]):\n+  \"\"\"Representation of a Python constant.\n+\n+  DO NOT INSTANTIATE THIS CLASS DIRECTLY! Doing so will create extra copies of\n+  constants, potentially causing subtle bugs. Instead, fetch the canonical\n+  instance of the constant using ctx.consts[constant].\n+  \"\"\"\n+\n+  def __init__(\n+      self, ctx: ContextType, constant: _T, allow_direct_instantiation=False):\n+    if self.__class__ is PythonConstant and not allow_direct_instantiation:\n+      raise ValueError('Do not instantiate PythonConstant directly. Use '\n+                       'ctx.consts[constant] instead.')\n+    super().__init__(ctx)\n+    self.constant = constant\n+\n+  def __repr__(self):\n+    return f'PythonConstant({self.constant!r})'\n+\n+  @property\n+  def _attrs(self):\n+    return (self.constant,)\n+\n+\n class Singleton(BaseValue):\n-  \"\"\"Singleton value.\"\"\"\n+  \"\"\"Singleton value.\n \n-  _INSTANCES: Dict[Tuple[ContextType, str], 'Singleton'] = {}\n-  name: str\n+  DO NOT INSTANTIATE THIS CLASS DIRECTLY! Doing so will create extra copies of\n+  singletons, potentially causing subtle bugs. Instead, fetch the canonical\n+  instance of the singleton using ctx.consts.singles[name].\n+  \"\"\"\n \n-  def __new__(cls, ctx: ContextType, name: str):\n-    key = (ctx, name)\n-    if key in cls._INSTANCES:\n-      return cls._INSTANCES[key]\n-    self = super().__new__(cls)\n-    cls._INSTANCES[key] = self\n-    return self\n+  name: str\n \n-  def __init__(self, ctx, name):\n+  def __init__(self, ctx, name, allow_direct_instantiation=False):\n+    if self.__class__ is Singleton and not allow_direct_instantiation:\n+      raise ValueError('Do not instantiate Singleton directly. Use '\n+                       'ctx.consts.singles[name] instead.')\n     super().__init__(ctx)\n     self.name = name\n \ndiff --git a/pytype/rewrite/abstract/classes.py b/pytype/rewrite/abstract/classes.py\nindex dca55c95a..26b0b8891 100644\n--- a/pytype/rewrite/abstract/classes.py\n+++ b/pytype/rewrite/abstract/classes.py\n@@ -4,7 +4,7 @@\n import dataclasses\n import logging\n \n-from typing import Dict, Generic, List, Mapping, Optional, Protocol, Sequence, TypeVar\n+from typing import Dict, List, Mapping, Optional, Protocol, Sequence\n \n import immutabledict\n from pytype.rewrite.abstract import base\n@@ -12,8 +12,6 @@\n \n log = logging.getLogger(__name__)\n \n-_T = TypeVar('_T')\n-\n \n class _HasMembers(Protocol):\n \n@@ -43,6 +41,14 @@ def __init__(\n     self.name = name\n     self.members = members\n     self.module = module\n+    self._canonical_instance: Optional['FrozenInstance'] = None\n+\n+    if isinstance((init := members.get('__init__')),\n+                  functions_lib.SimpleFunction):\n+      # An __init__ method is required to return None.\n+      for sig in init.signatures:\n+        if 'return' not in sig.annotations:\n+          sig.annotations['return'] = ctx.consts[None]\n \n     # These methods are attributes of individual classes so that they can be\n     # easily customized. For example, unittest.TestCase would want to add\n@@ -56,38 +62,53 @@ def __init__(\n     self.initializers = ['__init__']\n \n   def __repr__(self):\n-    return f'SimpleClass({self.name})'\n+    return f'SimpleClass({self.full_name})'\n \n   @property\n   def _attrs(self):\n-    return (self.name, immutabledict.immutabledict(self.members))\n+    return (self.module, self.name)\n+\n+  @property\n+  def full_name(self):\n+    if self.module:\n+      return f'{self.module}.{self.name}'\n+    else:\n+      return self.name\n \n   def get_attribute(self, name: str) -> Optional[base.BaseValue]:\n     return self.members.get(name)\n \n+  def set_attribute(self, name: str, value: base.BaseValue) -> None:\n+    # SimpleClass is used to model imported classes, which we treat as frozen.\n+    log.info('Ignoring attribute set on %r: %s -> %r',\n+             self, name, value)\n+\n   def instantiate(self) -> 'FrozenInstance':\n     \"\"\"Creates an instance of this class.\"\"\"\n+    log.info('Instantiating class %s', self.full_name)\n+    if self._canonical_instance:\n+      log.info('Reusing cached instance of class %s', self.full_name)\n+      return self._canonical_instance\n     for setup_method_name in self.setup_methods:\n       setup_method = self.get_attribute(setup_method_name)\n       if isinstance(setup_method, functions_lib.InterpreterFunction):\n         _ = setup_method.bind_to(self).analyze()\n     constructor = self.get_attribute(self.constructor)\n     if constructor:\n-      raise NotImplementedError('Custom __new__')\n-    else:\n-      instance = MutableInstance(self._ctx, self)\n+      log.error('Custom __new__ not yet implemented')\n+    instance = MutableInstance(self._ctx, self)\n     for initializer_name in self.initializers:\n       initializer = self.get_attribute(initializer_name)\n       if isinstance(initializer, functions_lib.InterpreterFunction):\n         _ = initializer.bind_to(instance).analyze()\n-    return instance.freeze()\n+    self._canonical_instance = frozen_instance = instance.freeze()\n+    return frozen_instance\n \n   def call(self, args: functions_lib.Args) -> ClassCallReturn:\n     constructor = self.get_attribute(self.constructor)\n     if constructor:\n-      raise NotImplementedError('Custom __new__')\n-    else:\n-      instance = MutableInstance(self._ctx, self)\n+      log.error('Custom __new__ not yet implemented')\n+    instance = MutableInstance(self._ctx, self)\n     for initializer_name in self.initializers:\n       initializer = self.get_attribute(initializer_name)\n       if isinstance(initializer, functions_lib.InterpreterFunction):\n@@ -112,6 +133,10 @@ def __init__(\n   def __repr__(self):\n     return f'InterpreterClass({self.name})'\n \n+  @property\n+  def _attrs(self):\n+    return (self.name, immutabledict.immutabledict(self.members))\n+\n \n class BaseInstance(base.BaseValue):\n   \"\"\"Instance of a class.\"\"\"\n@@ -126,10 +151,6 @@ def __init__(self, ctx: base.ContextType, cls: SimpleClass, members):\n   @abc.abstractmethod\n   def set_attribute(self, name: str, value: base.BaseValue) -> None: ...\n \n-  @property\n-  def _attrs(self):\n-    return (self.cls, immutabledict.immutabledict(self.members))\n-\n   def get_attribute(self, name: str) -> Optional[base.BaseValue]:\n     if name in self.members:\n       return self.members[name]\n@@ -139,26 +160,6 @@ def get_attribute(self, name: str) -> Optional[base.BaseValue]:\n     return cls_attribute\n \n \n-class PythonConstant(BaseInstance, Generic[_T]):\n-  \"\"\"Representation of a Python constant.\"\"\"\n-\n-  def __init__(self, ctx: base.ContextType, constant: _T):\n-    cls = ctx.abstract_loader.raw_type_to_value(type(constant))\n-    super().__init__(ctx, cls, {})\n-    self.constant = constant\n-\n-  def __repr__(self):\n-    return f'PythonConstant({self.constant!r})'\n-\n-  @property\n-  def _attrs(self):\n-    return (self.constant,)\n-\n-  def set_attribute(self, name: str, value: base.BaseValue) -> None:\n-    # TODO(b/241479600): Log an error.\n-    raise NotImplementedError('Cannot set attribute on a constant')\n-\n-\n class MutableInstance(BaseInstance):\n   \"\"\"Instance of a class.\"\"\"\n \n@@ -170,6 +171,10 @@ def __init__(self, ctx: base.ContextType, cls: SimpleClass):\n   def __repr__(self):\n     return f'MutableInstance({self.cls.name})'\n \n+  @property\n+  def _attrs(self):\n+    return (self.cls, immutabledict.immutabledict(self.members))\n+\n   def set_attribute(self, name: str, value: base.BaseValue) -> None:\n     if name in self.members:\n       self.members[name] = base.Union(self._ctx, (self.members[name], value))\n@@ -194,6 +199,12 @@ def __init__(self, ctx: base.ContextType, instance: MutableInstance):\n   def __repr__(self):\n     return f'FrozenInstance({self.cls.name})'\n \n+  @property\n+  def _attrs(self):\n+    # Since a FrozenInstance is the canonical instance of its class and cannot\n+    # change, the hash of the class is enough to uniquely identify it.\n+    return (self.cls,)\n+\n   def set_attribute(self, name: str, value: base.BaseValue) -> None:\n     # The VM may try to set an attribute on a frozen instance in the process of\n     # analyzing a class's methods. This is fine; we just ignore it.\ndiff --git a/pytype/rewrite/abstract/functions.py b/pytype/rewrite/abstract/functions.py\nindex 997df38dd..75de709b9 100644\n--- a/pytype/rewrite/abstract/functions.py\n+++ b/pytype/rewrite/abstract/functions.py\n@@ -17,6 +17,7 @@\n \n import abc\n import dataclasses\n+import logging\n from typing import Dict, Generic, Mapping, Optional, Protocol, Sequence, Tuple, TypeVar\n \n import immutabledict\n@@ -24,6 +25,8 @@\n from pytype.pytd import pytd\n from pytype.rewrite.abstract import base\n \n+log = logging.getLogger(__name__)\n+\n _EMPTY_MAP = immutabledict.immutabledict()\n _ArgDict = Dict[str, base.AbstractVariableType]\n \n@@ -31,6 +34,7 @@\n class FrameType(Protocol):\n   \"\"\"Protocol for a VM frame.\"\"\"\n \n+  name: str\n   final_locals: Mapping[str, base.BaseValue]\n   stack: Sequence['FrameType']\n \n@@ -51,7 +55,8 @@ def get_return_value(self) -> base.BaseValue: ...\n @dataclasses.dataclass\n class Args(Generic[_FrameT]):\n   \"\"\"Arguments to one function call.\"\"\"\n-  posargs: Sequence[base.AbstractVariableType] = ()\n+  posargs: Tuple[base.AbstractVariableType, ...] = ()\n+  kwargs: Mapping[str, base.AbstractVariableType] = _EMPTY_MAP\n   frame: Optional[_FrameT] = None\n \n \n@@ -228,6 +233,7 @@ def fmt(param_name):\n   def map_args(self, args: Args[_FrameT]) -> MappedArgs[_FrameT]:\n     # TODO(b/241479600): Implement this properly, with error detection.\n     argdict = dict(zip(self.param_names, args.posargs))\n+    argdict.update(args.kwargs)\n     return MappedArgs(signature=self, argdict=argdict, frame=args.frame)\n \n   def make_fake_args(self) -> MappedArgs[FrameType]:\n@@ -236,7 +242,10 @@ def make_fake_args(self) -> MappedArgs[FrameType]:\n       names.append(self.varargs_name)\n     if self.kwargs_name:\n       names.append(self.kwargs_name)\n-    argdict = {name: self._ctx.singles.Any.to_variable() for name in names}\n+    argdict = {}\n+    for name in names:\n+      typ = self.annotations.get(name, self._ctx.consts.Any)\n+      argdict[name] = typ.instantiate().to_variable()\n     return MappedArgs(signature=self, argdict=argdict)\n \n \n@@ -292,12 +301,19 @@ def __init__(\n     self.module = module\n \n   def __repr__(self):\n-    return f'SimpleFunction({self._name})'\n+    return f'SimpleFunction({self.full_name})'\n \n   @property\n   def name(self):\n     return self._name\n \n+  @property\n+  def full_name(self):\n+    if self.module:\n+      return f'{self.module}.{self._name}'\n+    else:\n+      return self._name\n+\n   @property\n   def signatures(self):\n     return self._signatures\n@@ -328,9 +344,12 @@ def call_with_mapped_args(\n   def call(self, args: Args[FrameType]) -> _HasReturnT:\n     return self.call_with_mapped_args(self.map_args(args))\n \n+  def analyze_signature(self, sig: Signature) -> _HasReturnT:\n+    assert sig in self.signatures\n+    return self.call_with_mapped_args(sig.make_fake_args())\n+\n   def analyze(self) -> Sequence[_HasReturnT]:\n-    return [self.call_with_mapped_args(sig.make_fake_args())\n-            for sig in self.signatures]\n+    return [self.analyze_signature(sig) for sig in self.signatures]\n \n \n class InterpreterFunction(SimpleFunction[_FrameT]):\n@@ -354,6 +373,7 @@ def __init__(\n     # A function saves a pointer to the frame it's defined in so that it has all\n     # the context needed to call itself.\n     self._parent_frame = parent_frame\n+    self._call_cache = {}\n \n   def __repr__(self):\n     return f'InterpreterFunction({self.name})'\n@@ -363,9 +383,22 @@ def _attrs(self):\n     return (self.name, self.code)\n \n   def call_with_mapped_args(self, mapped_args: MappedArgs[_FrameT]) -> _FrameT:\n+    log.info('Calling function:\\n  Sig:  %s\\n  Args: %s',\n+             mapped_args.signature, mapped_args.argdict)\n     parent_frame = mapped_args.frame or self._parent_frame\n+    if parent_frame.final_locals is None:\n+      k = None\n+    else:\n+      # If the parent frame has finished running, then the context of this call\n+      # will not change, so we can cache the return value.\n+      k = (parent_frame.name, immutabledict.immutabledict(mapped_args.argdict))\n+      if k in self._call_cache:\n+        log.info('Reusing cached return value of function %s', self.name)\n+        return self._call_cache[k]\n     frame = parent_frame.make_child_frame(self, mapped_args.argdict)\n     frame.run()\n+    if k:\n+      self._call_cache[k] = frame\n     return frame\n \n   def bind_to(self, callself: base.BaseValue) -> 'BoundFunction[_FrameT]':\n@@ -376,7 +409,8 @@ class PytdFunction(SimpleFunction[SimpleReturn]):\n \n   def call_with_mapped_args(\n       self, mapped_args: MappedArgs[FrameType]) -> SimpleReturn:\n-    return SimpleReturn(self._ctx.singles.Any)\n+    ret = mapped_args.signature.annotations['return'].instantiate()\n+    return SimpleReturn(ret)\n \n \n class BoundFunction(BaseFunction[_HasReturnT]):\n@@ -402,21 +436,20 @@ def name(self):\n \n   @property\n   def signatures(self):\n-    raise NotImplementedError('BoundFunction.signatures')\n+    return self.underlying.signatures\n+\n+  def call(self, args: Args[FrameType]) -> _HasReturnT:\n+    new_posargs = (self.callself.to_variable(),) + args.posargs\n+    args = dataclasses.replace(args, posargs=new_posargs)\n+    return self.underlying.call(args)\n \n-  def _bind_mapped_args(\n-      self, mapped_args: MappedArgs[_FrameT]) -> MappedArgs[_FrameT]:\n+  def analyze_signature(self, sig: Signature) -> _HasReturnT:\n+    assert sig in self.underlying.signatures\n+    mapped_args = sig.make_fake_args()\n     argdict = dict(mapped_args.argdict)\n     argdict[mapped_args.signature.param_names[0]] = self.callself.to_variable()\n-    return MappedArgs(mapped_args.signature, argdict, mapped_args.frame)\n-\n-  def call(self, args: Args[FrameType]) -> _HasReturnT:\n-    mapped_args = self._bind_mapped_args(self.underlying.map_args(args))\n-    return self.underlying.call_with_mapped_args(mapped_args)\n+    bound_args = dataclasses.replace(mapped_args, argdict=argdict)\n+    return self.underlying.call_with_mapped_args(bound_args)\n \n   def analyze(self) -> Sequence[_HasReturnT]:\n-    return [\n-        self.underlying.call_with_mapped_args(\n-            self._bind_mapped_args(sig.make_fake_args()))\n-        for sig in self.underlying.signatures\n-    ]\n+    return [self.analyze_signature(sig) for sig in self.underlying.signatures]\ndiff --git a/pytype/rewrite/abstract/instances.py b/pytype/rewrite/abstract/instances.py\nindex d839a0c59..49106b61c 100644\n--- a/pytype/rewrite/abstract/instances.py\n+++ b/pytype/rewrite/abstract/instances.py\n@@ -2,10 +2,9 @@\n \n import logging\n \n-from typing import Dict as _Dict, List as _List, Set as _Set\n+from typing import Dict as _Dict, List as _List, Set as _Set, Tuple as _Tuple\n \n from pytype.rewrite.abstract import base\n-from pytype.rewrite.abstract import classes\n \n log = logging.getLogger(__name__)\n \n@@ -13,7 +12,7 @@\n _Variable = base.AbstractVariableType\n \n \n-class List(classes.PythonConstant[_List[_Variable]]):\n+class List(base.PythonConstant[_List[_Variable]]):\n   \"\"\"Representation of a Python list.\"\"\"\n \n   def __init__(self, ctx: base.ContextType, constant: _List[_Variable]):\n@@ -27,7 +26,7 @@ def append(self, val: _Variable):\n     self.constant.append(val)\n \n \n-class Dict(classes.PythonConstant[_Dict[_Variable, _Variable]]):\n+class Dict(base.PythonConstant[_Dict[_Variable, _Variable]]):\n   \"\"\"Representation of a Python dict.\"\"\"\n \n   def __init__(\n@@ -43,7 +42,7 @@ def setitem(self, key, val):\n     self.constant[key] = val\n \n \n-class Set(classes.PythonConstant[_Set[_Variable]]):\n+class Set(base.PythonConstant[_Set[_Variable]]):\n   \"\"\"Representation of a Python set.\"\"\"\n \n   def __init__(self, ctx: base.ContextType, constant: _Set[_Variable]):\n@@ -55,3 +54,14 @@ def __repr__(self):\n \n   def add(self, val: _Variable):\n     self.constant.add(val)\n+\n+\n+class Tuple(base.PythonConstant[_Tuple[_Variable, ...]]):\n+  \"\"\"Representation of a Python tuple.\"\"\"\n+\n+  def __init__(self, ctx: base.ContextType, constant: _Tuple[_Variable, ...]):\n+    assert isinstance(constant, tuple), constant\n+    super().__init__(ctx, constant)\n+\n+  def __repr__(self):\n+    return f'Tuple({self.constant!r})'\ndiff --git a/pytype/rewrite/abstract/utils.py b/pytype/rewrite/abstract/utils.py\nindex d31342763..43430e745 100644\n--- a/pytype/rewrite/abstract/utils.py\n+++ b/pytype/rewrite/abstract/utils.py\n@@ -3,7 +3,6 @@\n from typing import Any, Sequence, Type, TypeVar, get_origin, overload\n \n from pytype.rewrite.abstract import base\n-from pytype.rewrite.abstract import classes\n \n _T = TypeVar('_T')\n \n@@ -19,7 +18,7 @@ def get_atomic_constant(var: base.AbstractVariableType, typ: None = ...) -> Any:\n \n \n def get_atomic_constant(var, typ=None):\n-  value = var.get_atomic_value(classes.PythonConstant)\n+  value = var.get_atomic_value(base.PythonConstant)\n   constant = value.constant\n   if typ and not isinstance(constant, (runtime_type := get_origin(typ) or typ)):\n     raise ValueError(\n@@ -35,4 +34,4 @@ def join_values(\n   elif values:\n     return values[0]\n   else:\n-    return ctx.singles.Any\n+    return ctx.consts.Any\ndiff --git a/pytype/rewrite/context.py b/pytype/rewrite/context.py\nindex 057e1a211..45545650c 100644\n--- a/pytype/rewrite/context.py\n+++ b/pytype/rewrite/context.py\n@@ -18,7 +18,6 @@\n from pytype.rewrite import load_abstract\n from pytype.rewrite import output\n from pytype.rewrite import pretty_printer\n-from pytype.rewrite.abstract import abstract\n \n \n class Context:\n@@ -30,11 +29,11 @@ class Context:\n   options: config.Options\n   pytd_loader: load_pytd.Loader\n \n-  singles: abstract.Singletons\n   errorlog: errors.VmErrorLog\n   abstract_converter: convert.AbstractConverter\n   abstract_loader: load_abstract.AbstractLoader\n   pytd_converter: output.PytdConverter\n+  consts: load_abstract.Constants\n \n   def __init__(\n       self,\n@@ -44,8 +43,10 @@ def __init__(\n     self.options = options or config.Options.create()\n     self.pytd_loader = pytd_loader or load_pytd.create_loader(self.options)\n \n-    self.singles = abstract.Singletons(self)\n     self.errorlog = errors.VmErrorLog(pretty_printer.PrettyPrinter(self))\n     self.abstract_converter = convert.AbstractConverter(self)\n     self.abstract_loader = load_abstract.AbstractLoader(self, self.pytd_loader)\n     self.pytd_converter = output.PytdConverter(self)\n+\n+    # We access these all the time, so create a convenient alias.\n+    self.consts = self.abstract_loader.consts\ndiff --git a/pytype/rewrite/convert.py b/pytype/rewrite/convert.py\nindex 9027d4b7a..52f2a5aa2 100644\n--- a/pytype/rewrite/convert.py\n+++ b/pytype/rewrite/convert.py\n@@ -34,18 +34,15 @@ def pytd_class_to_value(self, cls: pytd.Class) -> abstract.SimpleClass:\n     # Cache the class early so that references to it in its members don't cause\n     # infinite recursion.\n     self._cache.classes[cls] = abstract_class\n-    # TODO(b/324464265): For now, don't convert the bodies of builtin classes\n-    # because they contain lots of stuff the converter doesn't yet support.\n-    if not cls.name.startswith('builtins.'):\n-      for method in cls.methods:\n-        abstract_class.members[method.name] = (\n-            self.pytd_function_to_value(method))\n-      for constant in cls.constants:\n-        constant_type = self.pytd_type_to_value(constant.type)\n-        abstract_class.members[constant.name] = constant_type.instantiate()\n-      for nested_class in cls.classes:\n-        abstract_class.members[nested_class.name] = (\n-            self.pytd_class_to_value(nested_class))\n+    for method in cls.methods:\n+      abstract_class.members[method.name] = (\n+          self.pytd_function_to_value(method))\n+    for constant in cls.constants:\n+      constant_type = self.pytd_type_to_value(constant.type)\n+      abstract_class.members[constant.name] = constant_type.instantiate()\n+    for nested_class in cls.classes:\n+      abstract_class.members[nested_class.name] = (\n+          self.pytd_class_to_value(nested_class))\n     return abstract_class\n \n   def pytd_function_to_value(\n@@ -86,16 +83,26 @@ def _pytd_type_to_value(self, typ: pytd.Type) -> abstract.BaseValue:\n     if isinstance(typ, pytd.ClassType):\n       return self.pytd_class_to_value(typ.cls)\n     elif isinstance(typ, pytd.AnythingType):\n-      return self._ctx.singles.Any\n+      return self._ctx.consts.singles['Any']\n     elif isinstance(typ, pytd.NothingType):\n-      return self._ctx.singles.Never\n-    elif isinstance(typ, (pytd.LateType,\n-                          pytd.Literal,\n-                          pytd.Annotated,\n-                          pytd.TypeParameter,\n-                          pytd.UnionType,\n-                          pytd.IntersectionType,\n-                          pytd.GenericType)):\n+      return self._ctx.consts.singles['Never']\n+    elif isinstance(typ, pytd.UnionType):\n+      return abstract.Union(\n+          self._ctx, tuple(self._pytd_type_to_value(t) for t in typ.type_list))\n+    # TODO(b/324464265): Everything from this point onward is a dummy\n+    # implementation that needs to be replaced by a real one.\n+    elif isinstance(typ, pytd.GenericType):\n+      return self._pytd_type_to_value(typ.base_type)\n+    elif isinstance(typ, pytd.TypeParameter):\n+      return self._ctx.consts.Any\n+    elif isinstance(typ, pytd.Literal):\n+      return self._ctx.abstract_loader.load_raw_type(type(typ.value))\n+    elif isinstance(typ, pytd.Annotated):\n+      # We discard the Annotated wrapper for now, but we will need to keep track\n+      # of it because Annotated is a special form that can be used in generic\n+      # type aliases.\n+      return self._pytd_type_to_value(typ.base_type)\n+    elif isinstance(typ, (pytd.LateType, pytd.IntersectionType)):\n       raise NotImplementedError(\n           f'Abstract conversion not yet implemented for {typ}')\n     else:\ndiff --git a/pytype/rewrite/flow/variables.py b/pytype/rewrite/flow/variables.py\nindex f054d5881..9bcfeac5e 100644\n--- a/pytype/rewrite/flow/variables.py\n+++ b/pytype/rewrite/flow/variables.py\n@@ -31,8 +31,9 @@ class Variable(Generic[_T]):\n   name: Optional[str] = None\n \n   @classmethod\n-  def from_value(cls, value: _T2) -> 'Variable[_T2]':\n-    return cls((Binding(value),))\n+  def from_value(\n+      cls, value: _T2, *, name: Optional[str] = None) -> 'Variable[_T2]':\n+    return cls(bindings=(Binding(value),), name=name)\n \n   @property\n   def values(self) -> Tuple[_T, ...]:\ndiff --git a/pytype/rewrite/frame.py b/pytype/rewrite/frame.py\nindex 0343e3c8b..e47aafd73 100644\n--- a/pytype/rewrite/frame.py\n+++ b/pytype/rewrite/frame.py\n@@ -1,6 +1,5 @@\n \"\"\"A frame of an abstract VM for type analysis of python bytecode.\"\"\"\n \n-import enum\n import logging\n from typing import Any, FrozenSet, List, Mapping, Optional, Sequence, Set, Type\n \n@@ -23,10 +22,8 @@\n _VarMap = Mapping[str, _AbstractVariable]\n _FrameFunction = abstract.InterpreterFunction['Frame']\n \n-\n-class _Scope(enum.Enum):\n-  ENCLOSING = enum.auto()\n-  GLOBAL = enum.auto()\n+# This enum will be used frequently, so alias it\n+_Flags = pyc_marshal.Flags\n \n \n class _ShadowedNonlocals:\n@@ -42,21 +39,17 @@ def add_enclosing(self, name: str) -> None:\n   def add_global(self, name: str) -> None:\n     self._globals.add(name)\n \n-  def has_scope(self, name: str, scope: _Scope) -> bool:\n-    if scope is _Scope.ENCLOSING:\n-      return name in self._enclosing\n-    elif scope is _Scope.GLOBAL:\n-      return name in self._globals\n-    else:\n-      raise ValueError(f'Unrecognized scope: {scope}')\n+  def has_enclosing(self, name: str):\n+    return name in self._enclosing\n \n-  def get_names(self, scope: _Scope) -> FrozenSet[str]:\n-    if scope is _Scope.ENCLOSING:\n-      return frozenset(self._enclosing)\n-    elif scope is _Scope.GLOBAL:\n-      return frozenset(self._globals)\n-    else:\n-      raise NotImplementedError(f'Unrecognized scope: {scope}')\n+  def has_global(self, name: str):\n+    return name in self._globals\n+\n+  def get_global_names(self) -> FrozenSet[str]:\n+    return frozenset(self._globals)\n+\n+  def get_enclosing_names(self) -> FrozenSet[str]:\n+    return frozenset(self._enclosing)\n \n \n class Frame(frame_base.FrameBase[abstract.BaseValue]):\n@@ -102,6 +95,8 @@ def __init__(\n     self._classes: List[abstract.InterpreterClass] = []\n     # All variables returned via RETURN_VALUE\n     self._returns: List[_AbstractVariable] = []\n+    # Function kwnames are stored in the vm by KW_NAMES and retrieved by CALL\n+    self._kw_names = ()\n \n   def __repr__(self):\n     return f'Frame({self.name})'\n@@ -189,23 +184,41 @@ def store_deref(self, name: str, var: _AbstractVariable) -> None:\n     else:\n       self.store_local(name, var)\n \n+  def _shadows_enclosing(self, name: str) -> bool:\n+    \"\"\"Does name shadow a variable from the enclosing scope?\"\"\"\n+    return self._shadowed_nonlocals.has_enclosing(name)\n+\n+  def _shadows_global(self, name: str) -> bool:\n+    \"\"\"Does name shadow a variable from the global scope?\"\"\"\n+    if self._is_module_frame:\n+      # This is the global scope, and so `name` cannot shadow anything.\n+      return False\n+    return self._shadowed_nonlocals.has_global(name)\n+\n   def load_local(self, name) -> _AbstractVariable:\n-    if (self._shadowed_nonlocals.has_scope(name, _Scope.ENCLOSING) or\n-        (not self._is_module_frame and\n-         self._shadowed_nonlocals.has_scope(name, _Scope.GLOBAL))):\n+    if self._shadows_enclosing(name) or self._shadows_global(name):\n       raise KeyError(name)\n     return self._current_state.load_local(name)\n \n   def load_enclosing(self, name) -> _AbstractVariable:\n-    if self._shadowed_nonlocals.has_scope(name, _Scope.ENCLOSING):\n+    if self._shadows_enclosing(name):\n       return self._current_state.load_local(name)\n     return self._initial_enclosing[name].with_name(name)\n \n   def load_global(self, name) -> _AbstractVariable:\n-    if (self._is_module_frame or\n-        self._shadowed_nonlocals.has_scope(name, _Scope.GLOBAL)):\n+    if self._shadows_global(name):\n       return self._current_state.load_local(name)\n-    return self._initial_globals[name].with_name(name)\n+    try:\n+      if self._is_module_frame:\n+        return self._current_state.load_local(name)\n+      else:\n+        return self._initial_globals[name].with_name(name)\n+    except KeyError:\n+      return self.load_builtin(name)\n+\n+  def load_builtin(self, name) -> _AbstractVariable:\n+    builtin = self._ctx.abstract_loader.load_builtin_by_name(name)\n+    return builtin.to_variable(name)\n \n   def load_deref(self, name) -> _AbstractVariable:\n     # When a name from a parent frame is referenced in a child frame, we make a\n@@ -231,7 +244,7 @@ def make_child_frame(\n     initial_enclosing = {}\n     for name in func.enclosing_scope:\n       if name in current_locals:\n-        assert not self._shadowed_nonlocals.has_scope(name, _Scope.GLOBAL)\n+        assert not self._shadows_global(name)\n         initial_enclosing[name] = current_locals[name]\n       else:\n         initial_enclosing[name] = self._initial_enclosing[name]\n@@ -240,7 +253,7 @@ def make_child_frame(\n       initial_globals = current_locals\n     else:\n       initial_globals = dict(self._initial_globals)\n-      for name in self._shadowed_nonlocals.get_names(_Scope.GLOBAL):\n+      for name in self._shadowed_nonlocals.get_global_names():\n         initial_globals[name] = current_locals[name]\n     return Frame(\n         ctx=self._ctx,\n@@ -286,10 +299,10 @@ def _merge_nonlocals_into(self, frame: Optional['Frame']) -> None:\n     if not frame:\n       return\n     # Store nonlocals.\n-    for name in self._shadowed_nonlocals.get_names(_Scope.ENCLOSING):\n+    for name in self._shadowed_nonlocals.get_enclosing_names():\n       var = self._final_locals[name]\n       frame.store_deref(name, var)\n-    for name in self._shadowed_nonlocals.get_names(_Scope.GLOBAL):\n+    for name in self._shadowed_nonlocals.get_global_names():\n       var = self._final_locals[name]\n       frame.store_global(name, var)\n \n@@ -305,7 +318,7 @@ def _call_function(\n                            abstract.BoundFunction)):\n         ret = func.call(args)\n         ret_values.append(ret.get_return_value())\n-      elif func is self._ctx.singles.__build_class__:\n+      elif func is self._ctx.consts.singles['__build_class__']:\n         class_body, name = args.posargs\n         builder = class_body.get_atomic_value(_FrameFunction)\n         frame = builder.call(abstract.Args(frame=self))\n@@ -316,6 +329,7 @@ def _call_function(\n             functions=frame.functions,\n             classes=frame.classes,\n         )\n+        log.info('Created class: %s', cls.name)\n         self._classes.append(cls)\n         ret_values.append(cls)\n       else:\n@@ -352,11 +366,29 @@ def _pop_jump_if_false(self, opcode):\n     nojump_state = self._current_state.with_condition(conditions.Condition())\n     self._merge_state_into(nojump_state, opcode.next.index)\n \n+  # ---------------------------------------------------------------\n+  # Opcodes with no typing effects\n+\n+  def byte_NOP(self, opcode):\n+    del opcode  # unused\n+\n+  def byte_PRINT_EXPR(self, opcode):\n+    del opcode  # unused\n+    self._stack.pop_and_discard()\n+\n+  def byte_PRECALL(self, opcode):\n+    # Internal cpython use\n+    del opcode  # unused\n+\n   def byte_RESUME(self, opcode):\n+    # Internal cpython use\n     del opcode  # unused\n \n+  # ---------------------------------------------------------------\n+  # Load and store operations\n+\n   def byte_LOAD_CONST(self, opcode):\n-    constant = abstract.PythonConstant(self._ctx, self._code.consts[opcode.arg])\n+    constant = self._ctx.consts[self._code.consts[opcode.arg]]\n     self._stack.push(constant.to_variable())\n \n   def byte_RETURN_VALUE(self, opcode):\n@@ -382,26 +414,60 @@ def byte_STORE_ATTR(self, opcode):\n     full_name = f'{target.name}.{attr_name}'\n     self.store_local(full_name, attr)\n \n+  def _unpack_function_annotations(self, packed_annot):\n+    if self._code.python_version >= (3, 10):\n+      # In Python 3.10+, packed_annot is a tuple of variables:\n+      # (param_name1, param_type1, param_name2, param_type2, ...)\n+      annot_seq = abstract.get_atomic_constant(packed_annot, tuple)\n+      double_num_annots = len(annot_seq)\n+      assert not double_num_annots % 2\n+      annot = {}\n+      for i in range(double_num_annots // 2):\n+        name = abstract.get_atomic_constant(annot_seq[i*2], str)\n+        annot[name] = annot_seq[i*2 + 1]\n+    else:\n+      # Pre-3.10, packed_annot was a name->param_type dictionary.\n+      annot = abstract.get_atomic_constant(packed_annot, dict)\n+    return annot\n+\n   def byte_MAKE_FUNCTION(self, opcode):\n-    if opcode.arg not in (0, pyc_marshal.Flags.MAKE_FUNCTION_HAS_FREE_VARS):\n-      raise NotImplementedError('MAKE_FUNCTION not fully implemented')\n+    # Aliases for readability\n+    pop_const = lambda t: abstract.get_atomic_constant(self._stack.pop(), t)\n+    arg = opcode.arg\n+    # Get name and code object\n     if self._code.python_version >= (3, 11):\n-      code = abstract.get_atomic_constant(self._stack.pop(), blocks.OrderedCode)\n+      code = pop_const(blocks.OrderedCode)\n       name = code.qualname\n     else:\n-      name = abstract.get_atomic_constant(self._stack.pop(), str)\n-      code = abstract.get_atomic_constant(self._stack.pop(), blocks.OrderedCode)\n-    if opcode.arg & pyc_marshal.Flags.MAKE_FUNCTION_HAS_FREE_VARS:\n-      freevars = abstract.get_atomic_constant(self._stack.pop())\n+      name = pop_const(str)\n+      code = pop_const(blocks.OrderedCode)\n+    # Free vars\n+    if arg & _Flags.MAKE_FUNCTION_HAS_FREE_VARS:\n+      freevars = pop_const(tuple)\n       enclosing_scope = tuple(freevar.name for freevar in freevars)\n       assert all(enclosing_scope)\n     else:\n       enclosing_scope = ()\n+    # Annotations\n+    annot = {}\n+    if arg & _Flags.MAKE_FUNCTION_HAS_ANNOTATIONS:\n+      packed_annot = self._stack.pop()\n+      annot = self._unpack_function_annotations(packed_annot)\n+    # Defaults\n+    pos_defaults, kw_defaults = (), {}\n+    if arg & _Flags.MAKE_FUNCTION_HAS_POS_DEFAULTS:\n+      pos_defaults = pop_const(tuple)\n+    if arg & _Flags.MAKE_FUNCTION_HAS_KW_DEFAULTS:\n+      packed_kw_def = self._stack.pop()\n+      kw_defaults = packed_kw_def.get_atomic_value(abstract.ConstKeyDict)\n+    # Make function\n+    del annot, pos_defaults, kw_defaults  # TODO(b/241479600): Use these\n     func = abstract.InterpreterFunction(\n         self._ctx, name, code, enclosing_scope, self)\n-    if not (\n-        self._stack and\n-        self._stack.top().has_atomic_value(self._ctx.singles.__build_class__)):\n+    log.info('Created function: %s', func.name)\n+    if not (self._stack and\n+            self._stack.top().has_atomic_value(\n+                self._ctx.consts.singles['__build_class__'])):\n       # Class building makes and immediately calls a function that creates the\n       # class body; we don't need to store this function for later analysis.\n       self._functions.append(func)\n@@ -409,7 +475,7 @@ def byte_MAKE_FUNCTION(self, opcode):\n \n   def byte_PUSH_NULL(self, opcode):\n     del opcode  # unused\n-    self._stack.push(self._ctx.singles.NULL.to_variable())\n+    self._stack.push(self._ctx.consts.singles['NULL'].to_variable())\n \n   def byte_LOAD_NAME(self, opcode):\n     name = opcode.argval\n@@ -435,7 +501,7 @@ def byte_LOAD_GLOBAL(self, opcode):\n     if self._code.python_version >= (3, 11) and opcode.arg & 1:\n       # Compiler-generated marker that will be consumed in byte_CALL\n       # We are loading a global and calling it as a function.\n-      self._stack.push(self._ctx.singles.NULL.to_variable())\n+      self._stack.push(self._ctx.consts.singles['NULL'].to_variable())\n     name = opcode.argval\n     self._stack.push(self.load_global(name))\n \n@@ -451,30 +517,50 @@ def byte_LOAD_METHOD(self, opcode):\n     # this opcode should push two values onto the stack: either the unbound\n     # method and its `self` or NULL and the bound method. Since we always\n     # retrieve a bound method, we push the NULL\n-    self._stack.push(self._ctx.singles.NULL.to_variable())\n+    self._stack.push(self._ctx.consts.singles['NULL'].to_variable())\n     self._stack.push(self._load_attr(instance_var, method_name))\n \n-  def byte_PRECALL(self, opcode):\n-    del opcode  # unused\n+  # ---------------------------------------------------------------\n+  # Function and method calls\n+\n+  def byte_KW_NAMES(self, opcode):\n+    # Stores a list of kw names to be retrieved by CALL\n+    self._kw_names = opcode.argval\n+\n+  def _make_function_args(self, args):\n+    \"\"\"Unpack args into posargs and kwargs (3.11+).\"\"\"\n+    if self._kw_names:\n+      n_kw = len(self._kw_names)\n+      posargs = tuple(args[:-n_kw])\n+      kw_vals = args[-n_kw:]\n+      kwargs = immutabledict.immutabledict(zip(self._kw_names, kw_vals))\n+    else:\n+      posargs = tuple(args)\n+      kwargs = _EMPTY_MAP\n+    self._kw_names = ()\n+    return abstract.Args(posargs=posargs, kwargs=kwargs, frame=self)\n \n   def byte_CALL(self, opcode):\n     sentinel, *rest = self._stack.popn(opcode.arg + 2)\n-    if not sentinel.has_atomic_value(self._ctx.singles.NULL):\n+    if not sentinel.has_atomic_value(self._ctx.consts.singles['NULL']):\n       raise NotImplementedError('CALL not fully implemented')\n-    func_var, *args = rest\n-    self._call_function(func_var, abstract.Args(posargs=args, frame=self))\n+    func, *args = rest\n+    callargs = self._make_function_args(args)\n+    self._call_function(func, callargs)\n \n   def byte_CALL_FUNCTION(self, opcode):\n     args = self._stack.popn(opcode.arg)\n-    func_var = self._stack.pop()\n-    self._call_function(func_var, abstract.Args(posargs=args, frame=self))\n+    func = self._stack.pop()\n+    callargs = abstract.Args(posargs=tuple(args), frame=self)\n+    self._call_function(func, callargs)\n \n   def byte_CALL_METHOD(self, opcode):\n     args = self._stack.popn(opcode.arg)\n-    func_var = self._stack.pop()\n+    func = self._stack.pop()\n     # pop the NULL off the stack (see LOAD_METHOD)\n     self._stack.pop_and_discard()\n-    self._call_function(func_var, abstract.Args(posargs=args, frame=self))\n+    callargs = abstract.Args(posargs=tuple(args), frame=self)\n+    self._call_function(func, callargs)\n \n   # Pytype tracks variables in enclosing scopes by name rather than emulating\n   # the runtime's approach with cells and freevars, so we can ignore the opcodes\n@@ -486,7 +572,7 @@ def byte_COPY_FREE_VARS(self, opcode):\n     del opcode  # unused\n \n   def byte_LOAD_BUILD_CLASS(self, opcode):\n-    self._stack.push(self._ctx.singles.__build_class__.to_variable())\n+    self._stack.push(self._ctx.consts.singles['__build_class__'].to_variable())\n \n   # ---------------------------------------------------------------\n   # Build and extend collections\n@@ -503,7 +589,7 @@ def _build_collection_from_stack(\n     self._stack.push(constant.to_variable())\n \n   def byte_BUILD_TUPLE(self, opcode):\n-    self._build_collection_from_stack(opcode, tuple)\n+    self._build_collection_from_stack(opcode, tuple, factory=abstract.Tuple)\n \n   def byte_BUILD_LIST(self, opcode):\n     self._build_collection_from_stack(opcode, list, factory=abstract.List)\ndiff --git a/pytype/rewrite/load_abstract.py b/pytype/rewrite/load_abstract.py\nindex 437513c0d..d1e978b70 100644\n--- a/pytype/rewrite/load_abstract.py\n+++ b/pytype/rewrite/load_abstract.py\n@@ -1,12 +1,44 @@\n \"\"\"Loads abstract representations of imported objects.\"\"\"\n \n-from typing import Any, Dict, Type\n+from typing import Any as _Any, Dict, Type\n \n from pytype import load_pytd\n+from pytype.pytd import pytd\n from pytype.rewrite.abstract import abstract\n from pytype.rewrite.overlays import special_builtins\n \n \n+class Constants:\n+  \"\"\"Store of constants and singletons.\n+\n+  Constants should be accessed via self[<raw value>], which creates the constant\n+  if it does not exist. Under the hood, constants are stored in self._consts.\n+\n+  Singletons are stored in self.singles and should be accessed via\n+  self.singles[<name>]. For convenience, the Any singleton can also be accessed\n+  as self.Any.\n+  \"\"\"\n+\n+  _SINGLETONS = ('Any', '__build_class__', 'Never', 'NULL')\n+\n+  def __init__(self, ctx: abstract.ContextType):\n+    self._ctx = ctx\n+    self._consts: Dict[_Any, abstract.PythonConstant] = {}\n+    self.singles: Dict[str, abstract.Singleton] = {}\n+\n+    for single in self._SINGLETONS:\n+      self.singles[single] = abstract.Singleton(\n+          ctx, single, allow_direct_instantiation=True)\n+    # We use Any all the time, so alias it for convenience.\n+    self.Any = self.singles['Any']  # pylint: disable=invalid-name\n+\n+  def __getitem__(self, const: _Any):\n+    if const not in self._consts:\n+      self._consts[const] = abstract.PythonConstant(\n+          self._ctx, const, allow_direct_instantiation=True)\n+    return self._consts[const]\n+\n+\n class AbstractLoader:\n   \"\"\"Abstract loader.\"\"\"\n \n@@ -14,17 +46,45 @@ def __init__(self, ctx: abstract.ContextType, pytd_loader: load_pytd.Loader):\n     self._ctx = ctx\n     self._pytd_loader = pytd_loader\n \n+    self.consts = Constants(ctx)\n+    self._special_builtins = {\n+        'assert_type': special_builtins.AssertType(self._ctx),\n+    }\n+    self._special_builtins['NoneType'] = self.consts[None]\n+\n+  def _load_pytd_node(self, pytd_node: pytd.Node) -> abstract.BaseValue:\n+    if isinstance(pytd_node, pytd.Class):\n+      return self._ctx.abstract_converter.pytd_class_to_value(pytd_node)\n+    elif isinstance(pytd_node, pytd.Function):\n+      return self._ctx.abstract_converter.pytd_function_to_value(pytd_node)\n+    elif isinstance(pytd_node, pytd.Constant):\n+      typ = self._ctx.abstract_converter.pytd_type_to_value(pytd_node.type)\n+      return typ.instantiate()\n+    else:\n+      raise NotImplementedError(f'I do not know how to load {pytd_node}')\n+\n+  def load_builtin_by_name(self, name: str) -> abstract.BaseValue:\n+    if name in self._special_builtins:\n+      return self._special_builtins[name]\n+    pytd_node = self._pytd_loader.lookup_pytd('builtins', name)\n+    if isinstance(pytd_node, pytd.Constant):\n+      # This usage of eval is safe, as we've already checked that this is the\n+      # name of a builtin constant.\n+      return self.consts[eval(name)]  # pylint: disable=eval-used\n+    return self._load_pytd_node(pytd_node)\n+\n   def get_module_globals(self) -> Dict[str, abstract.BaseValue]:\n-    \"\"\"Gets a module's initial global namespace, including builtins.\"\"\"\n-    # TODO(b/324464265): Populate from builtins.pytd.\n+    \"\"\"Gets a module's initial global namespace.\"\"\"\n     return {\n-        '__name__': self._ctx.singles.Any,\n-        'assert_type': special_builtins.AssertType(self._ctx),\n-        'int': abstract.SimpleClass(\n-            self._ctx, name='int', module='builtins', members={}),\n+        # TODO(b/324464265): Represent __builtins__ as a module.\n+        '__builtins__': self.consts.Any,\n+        '__name__': self.consts['__main__'],\n+        '__file__': self.consts[self._ctx.options.input],\n+        '__doc__': self.consts[None],\n+        '__package__': self.consts[None],\n     }\n \n-  def raw_type_to_value(self, typ: Type[Any]) -> abstract.BaseValue:\n+  def load_raw_type(self, typ: Type[_Any]) -> abstract.BaseValue:\n     \"\"\"Converts a raw type to an abstract value.\n \n     Args:\n@@ -34,4 +94,7 @@ def raw_type_to_value(self, typ: Type[Any]) -> abstract.BaseValue:\n       The abstract representation of the type. For example, when passed `int`,\n       this function returns `abstract.SimpleClass(int)`.\n     \"\"\"\n-    return abstract.SimpleClass(self._ctx, typ.__name__, {}, typ.__module__)\n+    if typ is type(None):\n+      return self.consts[None]\n+    pytd_node = self._pytd_loader.lookup_pytd(typ.__module__, typ.__name__)\n+    return self._load_pytd_node(pytd_node)\ndiff --git a/pytype/rewrite/output.py b/pytype/rewrite/output.py\nindex 81088f22e..60a10c5fa 100644\n--- a/pytype/rewrite/output.py\n+++ b/pytype/rewrite/output.py\n@@ -1,5 +1,7 @@\n \"\"\"Abstract -> pytd converter.\"\"\"\n \n+from typing import Union\n+\n from pytype.pytd import pytd\n from pytype.pytd import pytd_utils\n from pytype.rewrite.abstract import abstract\n@@ -30,7 +32,7 @@ def to_pytd_def(self, val: abstract.BaseValue) -> pytd.Node:\n     \"\"\"\n     if isinstance(val, abstract.SimpleClass):\n       return self._class_to_pytd_def(val)\n-    elif isinstance(val, abstract.InterpreterFunction):\n+    elif isinstance(val, (abstract.SimpleFunction, abstract.BoundFunction)):\n       return self._function_to_pytd_def(val)\n     else:\n       raise NotImplementedError(\n@@ -41,9 +43,12 @@ def _class_to_pytd_def(self, val: abstract.SimpleClass) -> pytd.Class:\n     methods = []\n     constants = []\n     classes = []\n+    instance = val.instantiate()\n     for member_name, member_val in val.members.items():\n       if member_name in _IGNORED_CLASS_ATTRIBUTES:\n         continue\n+      if isinstance(member_val, abstract.SimpleFunction):\n+        member_val = member_val.bind_to(instance)\n       try:\n         member_type = self.to_pytd_def(member_val)\n       except NotImplementedError:\n@@ -59,7 +64,6 @@ def _class_to_pytd_def(self, val: abstract.SimpleClass) -> pytd.Class:\n         )\n         constants.append(\n             pytd.Constant(name=member_name, type=class_member_type))\n-    instance = val.instantiate()\n     for member_name, member_val in instance.members.items():\n       member_type = self.to_pytd_type(member_val)\n       constants.append(pytd.Constant(name=member_name, type=member_type))\n@@ -75,9 +79,8 @@ def _class_to_pytd_def(self, val: abstract.SimpleClass) -> pytd.Class:\n         template=(),\n     )\n \n-  def _function_to_pytd_def(\n-      self, val: abstract.InterpreterFunction) -> pytd.Function:\n-    \"\"\"Converts an abstract function to a pytd.Function.\"\"\"\n+  def _signature_to_pytd(self, sig: abstract.Signature) -> pytd.Signature:\n+    \"\"\"Converts a signature to a pytd.Signature.\"\"\"\n \n     def get_pytd(param_name):\n       if param_name in sig.annotations:\n@@ -85,59 +88,70 @@ def get_pytd(param_name):\n       else:\n         return pytd.AnythingType()\n \n+    params = []\n+    for i, param_name in enumerate(sig.param_names):\n+      if i < sig.posonly_count:\n+        param_kind = pytd.ParameterKind.POSONLY\n+      else:\n+        param_kind = pytd.ParameterKind.REGULAR\n+      params.append((param_name, param_kind))\n+    params.extend((param_name, pytd.ParameterKind.KWONLY)\n+                  for param_name in sig.kwonly_params)\n+    pytd_params = tuple(pytd.Parameter(\n+        name=param_name,\n+        type=get_pytd(param_name),\n+        kind=param_kind,\n+        optional=param_name in sig.defaults,\n+        mutated_type=None,\n+    ) for param_name, param_kind in params)\n+    if sig.varargs_name:\n+      starargs = pytd.Parameter(\n+          name=sig.varargs_name,\n+          type=get_pytd(sig.varargs_name),\n+          kind=pytd.ParameterKind.REGULAR,\n+          optional=True,\n+          mutated_type=None,\n+      )\n+    else:\n+      starargs = None\n+    if sig.kwargs_name:\n+      starstarargs = pytd.Parameter(\n+          name=sig.kwargs_name,\n+          type=get_pytd(sig.kwargs_name),\n+          kind=pytd.ParameterKind.REGULAR,\n+          optional=True,\n+          mutated_type=None,\n+      )\n+    else:\n+      starstarargs = None\n+    if 'return' in sig.annotations:\n+      ret_type = self.to_pytd_type_of_instance(sig.annotations['return'])\n+    else:\n+      ret_type = pytd.AnythingType()\n+    return pytd.Signature(\n+        params=pytd_params,\n+        starargs=starargs,\n+        starstarargs=starstarargs,\n+        return_type=ret_type,\n+        exceptions=(),\n+        template=(),\n+    )\n+\n+  def _function_to_pytd_def(\n+      self,\n+      val: Union[abstract.SimpleFunction, abstract.BoundFunction],\n+  ) -> pytd.Function:\n+    \"\"\"Converts an abstract function to a pytd.Function.\"\"\"\n     pytd_sigs = []\n     for sig in val.signatures:\n-      params = []\n-      for i, param_name in enumerate(sig.param_names):\n-        if i < sig.posonly_count:\n-          param_kind = pytd.ParameterKind.POSONLY\n-        else:\n-          param_kind = pytd.ParameterKind.REGULAR\n-        params.append((param_name, param_kind))\n-      params.extend((param_name, pytd.ParameterKind.KWONLY)\n-                    for param_name in sig.kwonly_params)\n-      pytd_params = tuple(pytd.Parameter(\n-          name=param_name,\n-          type=get_pytd(param_name),\n-          kind=param_kind,\n-          optional=param_name in sig.defaults,\n-          mutated_type=None,\n-      ) for param_name, param_kind in params)\n-      if sig.varargs_name:\n-        starargs = pytd.Parameter(\n-            name=sig.varargs_name,\n-            type=get_pytd(sig.varargs_name),\n-            kind=pytd.ParameterKind.REGULAR,\n-            optional=True,\n-            mutated_type=None,\n-        )\n-      else:\n-        starargs = None\n-      if sig.kwargs_name:\n-        starstarargs = pytd.Parameter(\n-            name=sig.kwargs_name,\n-            type=get_pytd(sig.kwargs_name),\n-            kind=pytd.ParameterKind.REGULAR,\n-            optional=True,\n-            mutated_type=None,\n-        )\n-      else:\n-        starstarargs = None\n-      if 'return' in sig.annotations:\n-        ret_type = self.to_pytd_type_of_instance(sig.annotations['return'])\n-      else:\n-        func_frame = val.call_with_mapped_args(sig.make_fake_args())\n-        ret_type = self.to_pytd_type(func_frame.get_return_value())\n-      pytd_sigs.append(pytd.Signature(\n-          params=pytd_params,\n-          starargs=starargs,\n-          starstarargs=starstarargs,\n-          return_type=ret_type,\n-          exceptions=(),\n-          template=(),\n-      ))\n+      pytd_sig = self._signature_to_pytd(sig)\n+      if 'return' not in sig.annotations:\n+        ret = val.analyze_signature(sig)\n+        ret_type = self.to_pytd_type(ret.get_return_value())\n+        pytd_sig = pytd_sig.Replace(return_type=ret_type)\n+      pytd_sigs.append(pytd_sig)\n     return pytd.Function(\n-        name=val.code.name,\n+        name=val.name.rsplit('.', 1)[-1],\n         signatures=tuple(pytd_sigs),\n         kind=pytd.MethodKind.METHOD,\n     )\n@@ -153,7 +167,7 @@ def to_pytd_type(self, val: abstract.BaseValue) -> pytd.Type:\n     Args:\n       val: The abstract value.\n     \"\"\"\n-    if val is self._ctx.singles.Any:\n+    if val is self._ctx.consts.Any:\n       return pytd.AnythingType()\n     elif isinstance(val, abstract.Union):\n       return pytd_utils.JoinTypes(self.to_pytd_type(v) for v in val.options)\n@@ -205,8 +219,10 @@ def to_pytd_type_of_instance(self, val: abstract.BaseValue) -> pytd.Type:\n     Args:\n       val: The abstract value.\n     \"\"\"\n-    if val is self._ctx.singles.Any:\n+    if val is self._ctx.consts.Any:\n       return pytd.AnythingType()\n+    elif val is self._ctx.consts[None]:\n+      return pytd.NamedType('builtins.NoneType')\n     elif isinstance(val, abstract.Union):\n       return pytd_utils.JoinTypes(self.to_pytd_type_of_instance(v)\n                                   for v in val.options)\ndiff --git a/pytype/rewrite/overlays/special_builtins.py b/pytype/rewrite/overlays/special_builtins.py\nindex 9780fa984..25cd48c8c 100644\n--- a/pytype/rewrite/overlays/special_builtins.py\n+++ b/pytype/rewrite/overlays/special_builtins.py\n@@ -26,4 +26,4 @@ def call_with_mapped_args(\n     if actual != expected:\n       stack = frame.stack if (frame := mapped_args.frame) else None\n       self._ctx.errorlog.assert_type(stack, actual, expected)\n-    return abstract.SimpleReturn(abstract.PythonConstant(self._ctx, None))\n+    return abstract.SimpleReturn(self._ctx.consts[None])\ndiff --git a/pytype/rewrite/vm.py b/pytype/rewrite/vm.py\nindex 7281aab70..dd483a364 100644\n--- a/pytype/rewrite/vm.py\n+++ b/pytype/rewrite/vm.py\n@@ -1,5 +1,6 @@\n \"\"\"An abstract virtual machine for type analysis of python bytecode.\"\"\"\n \n+import logging\n from typing import Dict, Optional, Sequence\n \n from pytype import config\n@@ -11,6 +12,8 @@\n from pytype.rewrite import frame as frame_lib\n from pytype.rewrite.abstract import abstract\n \n+log = logging.getLogger(__name__)\n+\n \n class VirtualMachine:\n   \"\"\"Virtual machine.\"\"\"\n@@ -45,25 +48,33 @@ def _run_module(self) -> None:\n \n   def analyze_all_defs(self) -> None:\n     \"\"\"Analyzes all class and function definitions.\"\"\"\n+    log.info('Running module-level code')\n     self._run_module()\n     parent_frames = [self._module_frame]\n     while parent_frames:\n       parent_frame = parent_frames.pop(0)\n       for f in parent_frame.functions:\n+        log.info('Analyzing %s', f.full_name)\n         parent_frames.extend(f.analyze())\n       classes = _collect_classes(parent_frame)\n       for cls in classes:\n         instance = cls.instantiate()\n+        skip = cls.setup_methods + [cls.constructor] + cls.initializers\n         for f in cls.functions:\n-          parent_frames.extend(f.bind_to(instance).analyze())\n+          if f.name.rsplit('.')[-1] in skip:\n+            continue\n+          method = f.bind_to(instance)\n+          log.info('Analyzing %s', method.full_name)\n+          parent_frames.extend(method.analyze())\n \n   def infer_stub(self) -> pytd.TypeDeclUnit:\n     \"\"\"Infers a type stub.\"\"\"\n     self._run_module()\n     pytd_nodes = []\n     for name, value in self._module_frame.final_locals.items():\n-      if name in self._initial_globals and value == self._initial_globals[name]:\n+      if name in self._initial_globals:\n         continue\n+      log.info(\"Inferring type of '%s: %s'\", name, value)\n       try:\n         pytd_node = value.to_pytd_def()\n       except NotImplementedError:\ndiff --git a/pytype/stubs/builtins/builtins.pytd b/pytype/stubs/builtins/builtins.pytd\nindex 0e4516a16..5c7cb687e 100644\n--- a/pytype/stubs/builtins/builtins.pytd\n+++ b/pytype/stubs/builtins/builtins.pytd\n@@ -1053,9 +1053,9 @@ class type(Callable, Type[_T]):\n     def __new__(cls: Type[type], object: _T) -> Type[_T]: ...\n     # The return type in the below two definitions is used only when abstract.py\n     # isn't able to build a class from the arguments.\n-    def __new__(cls: Type[type], name: str, bases: tuple[type, ...], dict: Dict[str, Any]) -> type: ...\n+    def __new__(cls: Type[type], name: str, bases: tuple[type, ...], dict: Dict[str, Any], **kwargs) -> type: ...\n     def __init__(self, object) -> None: ...\n-    def __init__(self, name, bases, dict) -> None: ...\n+    def __init__(self, name, bases, dict,  **kwargs) -> None: ...\n     def __subclasses__(self) -> List[type]: ...\n     def __instancecheck__(self, object) -> bool: ...\n     def __subclasscheck__(self, cls) -> bool: ...\ndiff --git a/pytype/tools/analyze_project/pytype_runner.py b/pytype/tools/analyze_project/pytype_runner.py\nindex d9bcb519a..52a628f5b 100644\n--- a/pytype/tools/analyze_project/pytype_runner.py\n+++ b/pytype/tools/analyze_project/pytype_runner.py\n@@ -160,6 +160,7 @@ def escape_ninja_path(path: str):\n   \"\"\"\n   return re.sub(r'(?P<char>[\\n :$])', r'$\\g<char>', path)\n \n+\n def get_imports_map(deps, module_to_imports_map, module_to_output):\n   \"\"\"Get a short path -> full path map for the given deps.\"\"\"\n   imports_map = {}\n",
    "repo": "google/pytype",
    "base_commit": "52d8e44d739083fdb4d0e45145ca6397ad713e63",
    "hints_text": "",
    "created_at": "2024-04-09T04:02:57Z",
    "test_patch": "diff --git a/pytype/rewrite/abstract/base_test.py b/pytype/rewrite/abstract/base_test.py\nindex 02a4b4f4a..9732f584e 100644\n--- a/pytype/rewrite/abstract/base_test.py\n+++ b/pytype/rewrite/abstract/base_test.py\n@@ -7,58 +7,91 @@\n import unittest\n \n \n-class BaseValueTest(test_utils.ContextfulTestBase):\n+class FakeValue(base.BaseValue):\n+\n+  def __repr__(self):\n+    return 'FakeValue'\n+\n+  @property\n+  def _attrs(self):\n+    return (id(self),)\n+\n+\n+class TestBase(test_utils.ContextfulTestBase):\n+\n+  def _const(self, const):\n+    return base.PythonConstant(self.ctx, const, allow_direct_instantiation=True)\n+\n+\n+class BaseValueTest(TestBase):\n \n   def test_to_variable(self):\n+    v = FakeValue(self.ctx)\n+    var = v.to_variable()\n+    assert_type(var, variables.Variable[FakeValue])\n+    self.assertEqual(var.get_atomic_value(), v)\n+    self.assertIsNone(var.name)\n+\n+  def test_name(self):\n+    var = FakeValue(self.ctx).to_variable('NamedVariable')\n+    self.assertEqual(var.name, 'NamedVariable')\n+\n+\n+class PythonConstantTest(TestBase):\n+\n+  def test_equal(self):\n+    c1 = self._const('a')\n+    c2 = self._const('a')\n+    self.assertEqual(c1, c2)\n \n-    class C(base.BaseValue):\n+  def test_not_equal(self):\n+    c1 = self._const('a')\n+    c2 = self._const('b')\n+    self.assertNotEqual(c1, c2)\n \n-      def __repr__(self):\n-        return 'C'\n+  def test_constant_type(self):\n+    c = self._const('a')\n+    assert_type(c.constant, str)\n \n-      @property\n-      def _attrs(self):\n-        return (id(self),)\n+  def test_get_type_from_variable(self):\n+    var = self._const(True).to_variable()\n+    const = var.get_atomic_value(base.PythonConstant[int]).constant\n+    assert_type(const, int)\n \n-    c = C(self.ctx)\n-    var = c.to_variable()\n-    assert_type(var, variables.Variable[C])\n-    self.assertEqual(var.get_atomic_value(), c)\n+  def test_direct_instantiation(self):\n+    with self.assertRaises(ValueError):\n+      base.PythonConstant(self.ctx, None)\n \n \n-class SingletonTest(test_utils.ContextfulTestBase):\n+class SingletonTest(TestBase):\n \n-  def test_duplicate(self):\n-    s1 = base.Singleton(self.ctx, 'TEST_SINGLETON')\n-    s2 = base.Singleton(self.ctx, 'TEST_SINGLETON')\n-    self.assertIs(s1, s2)\n+  def test_direct_instantiation(self):\n+    with self.assertRaises(ValueError):\n+      base.Singleton(self.ctx, 'TEST_SINGLETON')\n \n \n-class UnionTest(test_utils.ContextfulTestBase):\n+class UnionTest(TestBase):\n \n   def test_basic(self):\n-    options = (classes.PythonConstant(self.ctx, True),\n-               classes.PythonConstant(self.ctx, False))\n+    options = (self._const(True), self._const(False))\n     union = base.Union(self.ctx, options)\n     self.assertEqual(union.options, options)\n \n   def test_flatten(self):\n-    union1 = base.Union(self.ctx, (classes.PythonConstant(self.ctx, True),\n-                                   classes.PythonConstant(self.ctx, False)))\n-    union2 = base.Union(self.ctx, (union1, classes.PythonConstant(self.ctx, 5)))\n-    self.assertEqual(union2.options, (classes.PythonConstant(self.ctx, True),\n-                                      classes.PythonConstant(self.ctx, False),\n-                                      classes.PythonConstant(self.ctx, 5)))\n+    union1 = base.Union(self.ctx, (self._const(True), self._const(False)))\n+    union2 = base.Union(self.ctx, (union1, self._const(5)))\n+    self.assertEqual(union2.options,\n+                     (self._const(True), self._const(False), self._const(5)))\n \n   def test_deduplicate(self):\n-    true = classes.PythonConstant(self.ctx, True)\n-    false = classes.PythonConstant(self.ctx, False)\n+    true = self._const(True)\n+    false = self._const(False)\n     union = base.Union(self.ctx, (true, false, true))\n     self.assertEqual(union.options, (true, false))\n \n   def test_order(self):\n-    true = classes.PythonConstant(self.ctx, True)\n-    false = classes.PythonConstant(self.ctx, False)\n+    true = self._const(True)\n+    false = self._const(False)\n     self.assertEqual(base.Union(self.ctx, (true, false)),\n                      base.Union(self.ctx, (false, true)))\n \ndiff --git a/pytype/rewrite/abstract/classes_test.py b/pytype/rewrite/abstract/classes_test.py\nindex 09d7e51b2..d00cbc361 100644\n--- a/pytype/rewrite/abstract/classes_test.py\n+++ b/pytype/rewrite/abstract/classes_test.py\n@@ -1,7 +1,6 @@\n from pytype.rewrite.abstract import classes\n from pytype.rewrite.abstract import functions\n from pytype.rewrite.tests import test_utils\n-from typing_extensions import assert_type\n \n import unittest\n \n@@ -9,7 +8,7 @@\n class ClassTest(test_utils.ContextfulTestBase):\n \n   def test_get_attribute(self):\n-    x = classes.PythonConstant(self.ctx, 5)\n+    x = self.ctx.consts[5]\n     cls = classes.SimpleClass(self.ctx, 'X', {'x': x})\n     self.assertEqual(cls.get_attribute('x'), x)\n \n@@ -28,49 +27,25 @@ def test_call(self):\n     self.assertEqual(instance.cls, cls)\n \n \n-class PythonConstantTest(test_utils.ContextfulTestBase):\n-\n-  def test_equal(self):\n-    c1 = classes.PythonConstant(self.ctx, 'a')\n-    c2 = classes.PythonConstant(self.ctx, 'a')\n-    self.assertEqual(c1, c2)\n-\n-  def test_not_equal(self):\n-    c1 = classes.PythonConstant(self.ctx, 'a')\n-    c2 = classes.PythonConstant(self.ctx, 'b')\n-    self.assertNotEqual(c1, c2)\n-\n-  def test_constant_type(self):\n-    c = classes.PythonConstant(self.ctx, 'a')\n-    assert_type(c.constant, str)\n-\n-  def test_get_type_from_variable(self):\n-    var = classes.PythonConstant(self.ctx, True).to_variable()\n-    const = var.get_atomic_value(classes.PythonConstant[int]).constant\n-    assert_type(const, int)\n-\n-\n class MutableInstanceTest(test_utils.ContextfulTestBase):\n \n   def test_get_instance_attribute(self):\n     cls = classes.SimpleClass(self.ctx, 'X', {})\n     instance = classes.MutableInstance(self.ctx, cls)\n-    instance.members['x'] = classes.PythonConstant(self.ctx, 3)\n-    self.assertEqual(instance.get_attribute('x'),\n-                     classes.PythonConstant(self.ctx, 3))\n+    instance.members['x'] = self.ctx.consts[3]\n+    self.assertEqual(instance.get_attribute('x'), self.ctx.consts[3])\n \n   def test_get_class_attribute(self):\n     cls = classes.SimpleClass(\n-        self.ctx, 'X', {'x': classes.PythonConstant(self.ctx, 3)})\n+        self.ctx, 'X', {'x': self.ctx.consts[3]})\n     instance = classes.MutableInstance(self.ctx, cls)\n-    self.assertEqual(instance.get_attribute('x'),\n-                     classes.PythonConstant(self.ctx, 3))\n+    self.assertEqual(instance.get_attribute('x'), self.ctx.consts[3])\n \n   def test_set_attribute(self):\n     cls = classes.SimpleClass(self.ctx, 'X', {})\n     instance = classes.MutableInstance(self.ctx, cls)\n-    instance.set_attribute('x', classes.PythonConstant(self.ctx, 3))\n-    self.assertEqual(instance.members['x'], classes.PythonConstant(self.ctx, 3))\n+    instance.set_attribute('x', self.ctx.consts[3])\n+    self.assertEqual(instance.members['x'], self.ctx.consts[3])\n \n \n class FrozenInstanceTest(test_utils.ContextfulTestBase):\n@@ -78,10 +53,9 @@ class FrozenInstanceTest(test_utils.ContextfulTestBase):\n   def test_get_attribute(self):\n     cls = classes.SimpleClass(self.ctx, 'X', {})\n     mutable_instance = classes.MutableInstance(self.ctx, cls)\n-    mutable_instance.set_attribute('x', classes.PythonConstant(self.ctx, 3))\n+    mutable_instance.set_attribute('x', self.ctx.consts[3])\n     instance = mutable_instance.freeze()\n-    self.assertEqual(instance.get_attribute('x'),\n-                     classes.PythonConstant(self.ctx, 3))\n+    self.assertEqual(instance.get_attribute('x'), self.ctx.consts[3])\n \n \n if __name__ == '__main__':\ndiff --git a/pytype/rewrite/abstract/functions_test.py b/pytype/rewrite/abstract/functions_test.py\nindex b109eca83..87f745546 100644\n--- a/pytype/rewrite/abstract/functions_test.py\n+++ b/pytype/rewrite/abstract/functions_test.py\n@@ -12,6 +12,7 @@ class FakeFrame:\n \n   def __init__(self, ctx):\n     self.ctx = ctx\n+    self.name = ''\n     self.child_frames = []\n     self.final_locals = {}\n     self.stack = [self]\n@@ -24,7 +25,7 @@ def run(self):\n     pass\n \n   def get_return_value(self):\n-    return self.ctx.singles.Any\n+    return self.ctx.consts.Any\n \n \n def _get_const(src: str):\n@@ -49,15 +50,21 @@ def f(x, /, *args, y, **kwargs):\n \n   def test_map_args(self):\n     signature = functions.Signature(self.ctx, 'f', ('x', 'y'))\n-    x = classes.PythonConstant(self.ctx, 'x').to_variable()\n-    y = classes.PythonConstant(self.ctx, 'y').to_variable()\n-    args = signature.map_args(functions.Args([x, y]))\n+    x = self.ctx.consts['x'].to_variable()\n+    y = self.ctx.consts['y'].to_variable()\n+    args = signature.map_args(functions.Args((x, y)))\n     self.assertEqual(args.argdict, {'x': x, 'y': y})\n \n   def test_fake_args(self):\n-    signature = functions.Signature(self.ctx, 'f', ('x', 'y'))\n+    annotations = {'x': self.ctx.abstract_loader.load_raw_type(int)}\n+    signature = functions.Signature(self.ctx, 'f', ('x', 'y'),\n+                                    annotations=annotations)\n     args = signature.make_fake_args()\n     self.assertEqual(set(args.argdict), {'x', 'y'})\n+    x = args.argdict['x'].get_atomic_value()\n+    self.assertIsInstance(x, classes.FrozenInstance)\n+    self.assertEqual(x.cls.name, 'int')\n+    self.assertEqual(args.argdict['y'].get_atomic_value(), self.ctx.consts.Any)\n \n   def test_from_pytd_basic(self):\n     sig = self.from_pytd('def f(): ...')\n@@ -96,7 +103,7 @@ def test_map_args(self):\n     f = functions.InterpreterFunction(\n         ctx=self.ctx, name='f', code=func_code, enclosing_scope=(),\n         parent_frame=FakeFrame(self.ctx))\n-    x = classes.PythonConstant(self.ctx, 0).to_variable()\n+    x = self.ctx.consts[0].to_variable()\n     mapped_args = f.map_args(functions.Args(posargs=(x,)))\n     self.assertEqual(mapped_args.signature, f.signatures[0])\n     self.assertEqual(mapped_args.argdict, {'x': x})\n@@ -105,7 +112,7 @@ def test_call_with_mapped_args(self):\n     f = functions.InterpreterFunction(\n         ctx=self.ctx, name='f', code=_get_const('def f(x): ...'),\n         enclosing_scope=(), parent_frame=FakeFrame(self.ctx))\n-    x = classes.PythonConstant(self.ctx, 0).to_variable()\n+    x = self.ctx.consts[0].to_variable()\n     mapped_args = functions.MappedArgs(f.signatures[0], {'x': x})\n     frame = f.call_with_mapped_args(mapped_args)\n     assert_type(frame, FakeFrame)\n@@ -129,13 +136,25 @@ def test_analyze(self):\n     self.assertIsInstance(frames[0], FakeFrame)\n \n \n+class PytdFunctionTest(test_utils.PytdTestBase,\n+                       test_utils.ContextfulTestBase):\n+\n+  def test_return(self):\n+    pytd_func = self.build_pytd('def f() -> int: ...')\n+    func = self.ctx.abstract_converter.pytd_function_to_value(pytd_func)\n+    args = functions.MappedArgs(signature=func.signatures[0], argdict={})\n+    ret = func.call_with_mapped_args(args).get_return_value()\n+    self.assertIsInstance(ret, classes.FrozenInstance)\n+    self.assertEqual(ret.cls.name, 'int')\n+\n+\n class BoundFunctionTest(test_utils.ContextfulTestBase):\n \n   def test_call(self):\n     f = functions.InterpreterFunction(\n         ctx=self.ctx, name='f', code=_get_const('def f(self): ...'),\n         enclosing_scope=(), parent_frame=FakeFrame(self.ctx))\n-    callself = classes.PythonConstant(self.ctx, 42)\n+    callself = self.ctx.consts[42]\n     bound_f = f.bind_to(callself)\n     frame = bound_f.call(functions.Args())\n     assert_type(frame, FakeFrame)\n@@ -146,7 +165,7 @@ def test_analyze(self):\n     f = functions.InterpreterFunction(\n         ctx=self.ctx, name='f', code=_get_const('def f(self): ...'),\n         enclosing_scope=(), parent_frame=FakeFrame(self.ctx))\n-    callself = classes.PythonConstant(self.ctx, 42)\n+    callself = self.ctx.consts[42]\n     bound_f = f.bind_to(callself)\n     frames = bound_f.analyze()\n     assert_type(frames, Sequence[FakeFrame])\ndiff --git a/pytype/rewrite/abstract/instances_test.py b/pytype/rewrite/abstract/instances_test.py\nindex 7fc8a4187..29c5bc046 100644\n--- a/pytype/rewrite/abstract/instances_test.py\n+++ b/pytype/rewrite/abstract/instances_test.py\n@@ -1,7 +1,6 @@\n-from typing import Dict, List\n+from typing import Dict, List, Set, Tuple\n \n from pytype.rewrite.abstract import base\n-from pytype.rewrite.abstract import classes\n from pytype.rewrite.abstract import instances\n from pytype.rewrite.tests import test_utils\n from typing_extensions import assert_type\n@@ -9,24 +8,48 @@\n import unittest\n \n # Type aliases\n-_Variable = base.AbstractVariableType\n+_AbstractVariable = base.AbstractVariableType\n \n \n-class ListTest(test_utils.ContextfulTestBase):\n+class BaseTest(test_utils.ContextfulTestBase):\n+  \"\"\"Base class for constant tests.\"\"\"\n+\n+  def const_var(self, const, name=None):\n+    return self.ctx.consts[const].to_variable(name)\n+\n+\n+class ListTest(BaseTest):\n \n   def test_constant_type(self):\n-    a = classes.PythonConstant(self.ctx, \"a\").to_variable()\n+    a = self.const_var(\"a\")\n     c = instances.List(self.ctx, [a])\n-    assert_type(c.constant, List[_Variable])\n+    assert_type(c.constant, List[_AbstractVariable])\n \n \n-class DictTest(test_utils.ContextfulTestBase):\n+class DictTest(BaseTest):\n \n   def test_constant_type(self):\n-    a = classes.PythonConstant(self.ctx, \"a\").to_variable()\n-    b = classes.PythonConstant(self.ctx, \"1\").to_variable()\n+    a = self.const_var(\"a\")\n+    b = self.const_var(\"b\")\n     c = instances.Dict(self.ctx, {a: b})\n-    assert_type(c.constant, Dict[_Variable, _Variable])\n+    assert_type(c.constant, Dict[_AbstractVariable, _AbstractVariable])\n+\n+\n+class SetTest(BaseTest):\n+\n+  def test_constant_type(self):\n+    a = self.const_var(\"a\")\n+    c = instances.Set(self.ctx, {a})\n+    assert_type(c.constant, Set[_AbstractVariable])\n+\n+\n+class TupleTest(BaseTest):\n+\n+  def test_constant_type(self):\n+    a = self.const_var(\"a\")\n+    b = self.const_var(\"b\")\n+    c = instances.Tuple(self.ctx, (a, b))\n+    assert_type(c.constant, Tuple[_AbstractVariable, ...])\n \n \n if __name__ == \"__main__\":\ndiff --git a/pytype/rewrite/abstract/internal_test.py b/pytype/rewrite/abstract/internal_test.py\nindex 5bd8e38dd..5e8748cb6 100644\n--- a/pytype/rewrite/abstract/internal_test.py\n+++ b/pytype/rewrite/abstract/internal_test.py\n@@ -1,6 +1,5 @@\n from typing import Any\n \n-from pytype.rewrite.abstract import classes\n from pytype.rewrite.abstract import internal\n from pytype.rewrite.tests import test_utils\n \n@@ -11,7 +10,7 @@ class ConstKeyDictTest(test_utils.ContextfulTestBase):\n \n   def test_asserts_dict(self):\n     _ = internal.ConstKeyDict(self.ctx, {\n-        'a': self.ctx.singles.Any.to_variable()\n+        'a': self.ctx.consts.Any.to_variable()\n     })\n     with self.assertRaises(AssertionError):\n       x: Any = ['a', 'b']\n@@ -22,8 +21,7 @@ class SplatTest(test_utils.ContextfulTestBase):\n \n   def test_basic(self):\n     # Basic smoke test, remove when we have some real functionality to test.\n-    seq = [classes.PythonConstant(self.ctx, i).to_variable()\n-           for i in range(3)]\n+    seq = [self.ctx.consts[i].to_variable() for i in range(3)]\n     x = internal.Splat(self.ctx, seq)\n     self.assertEqual(x.iterable, tuple(seq))\n \ndiff --git a/pytype/rewrite/abstract/utils_test.py b/pytype/rewrite/abstract/utils_test.py\nindex 545e63ebb..5ad9a9e86 100644\n--- a/pytype/rewrite/abstract/utils_test.py\n+++ b/pytype/rewrite/abstract/utils_test.py\n@@ -1,7 +1,6 @@\n from typing import Tuple\n \n from pytype.rewrite.abstract import base\n-from pytype.rewrite.abstract import classes\n from pytype.rewrite.abstract import utils\n from pytype.rewrite.tests import test_utils\n from typing_extensions import assert_type\n@@ -12,29 +11,29 @@\n class GetAtomicConstantTest(test_utils.ContextfulTestBase):\n \n   def test_get(self):\n-    var = classes.PythonConstant(self.ctx, 'a').to_variable()\n+    var = self.ctx.consts['a'].to_variable()\n     const = utils.get_atomic_constant(var)\n     self.assertEqual(const, 'a')\n \n   def test_get_with_type(self):\n-    var = classes.PythonConstant(self.ctx, 'a').to_variable()\n+    var = self.ctx.consts['a'].to_variable()\n     const = utils.get_atomic_constant(var, str)\n     assert_type(const, str)\n     self.assertEqual(const, 'a')\n \n   def test_get_with_bad_type(self):\n-    var = classes.PythonConstant(self.ctx, 'a').to_variable()\n+    var = self.ctx.consts['a'].to_variable()\n     with self.assertRaisesRegex(ValueError, 'expected int, got str'):\n       utils.get_atomic_constant(var, int)\n \n   def test_get_with_parameterized_type(self):\n-    var = classes.PythonConstant(self.ctx, ('a',)).to_variable()\n+    var = self.ctx.consts[('a',)].to_variable()\n     const = utils.get_atomic_constant(var, Tuple[str, ...])\n     assert_type(const, Tuple[str, ...])\n     self.assertEqual(const, ('a',))\n \n   def test_get_with_bad_parameterized_type(self):\n-    var = classes.PythonConstant(self.ctx, 'a').to_variable()\n+    var = self.ctx.consts['a'].to_variable()\n     with self.assertRaisesRegex(ValueError, 'expected tuple, got str'):\n       utils.get_atomic_constant(var, Tuple[str, ...])\n \n@@ -42,15 +41,15 @@ def test_get_with_bad_parameterized_type(self):\n class JoinValuesTest(test_utils.ContextfulTestBase):\n \n   def test_empty(self):\n-    self.assertEqual(utils.join_values(self.ctx, []), self.ctx.singles.Any)\n+    self.assertEqual(utils.join_values(self.ctx, []), self.ctx.consts.Any)\n \n   def test_one_value(self):\n-    a = classes.PythonConstant(self.ctx, 'a')\n+    a = self.ctx.consts['a']\n     self.assertEqual(utils.join_values(self.ctx, [a]), a)\n \n   def test_multiple_values(self):\n-    a = classes.PythonConstant(self.ctx, 'a')\n-    b = classes.PythonConstant(self.ctx, 'b')\n+    a = self.ctx.consts['a']\n+    b = self.ctx.consts['b']\n     val = utils.join_values(self.ctx, [a, b])\n     self.assertEqual(val, base.Union(self.ctx, (a, b)))\n \ndiff --git a/pytype/rewrite/convert_test.py b/pytype/rewrite/convert_test.py\nindex c1f825049..efd9fbcc3 100644\n--- a/pytype/rewrite/convert_test.py\n+++ b/pytype/rewrite/convert_test.py\n@@ -24,11 +24,11 @@ def test_class_type(self):\n \n   def test_anything_type(self):\n     abstract_value = self.conv.pytd_type_to_value(pytd.AnythingType())\n-    self.assertEqual(abstract_value, self.ctx.singles.Any)\n+    self.assertEqual(abstract_value, self.ctx.consts.singles['Any'])\n \n   def test_nothing_type(self):\n     abstract_value = self.conv.pytd_type_to_value(pytd.NothingType())\n-    self.assertEqual(abstract_value, self.ctx.singles.Never)\n+    self.assertEqual(abstract_value, self.ctx.consts.singles['Never'])\n \n \n class PytdFunctionToValueTest(ConverterTestBase):\ndiff --git a/pytype/rewrite/flow/variables_test.py b/pytype/rewrite/flow/variables_test.py\nindex 0ad789d13..179fa6792 100644\n--- a/pytype/rewrite/flow/variables_test.py\n+++ b/pytype/rewrite/flow/variables_test.py\n@@ -19,6 +19,11 @@ class VariableTest(unittest.TestCase):\n   def test_from_value(self):\n     var = variables.Variable.from_value(0)\n     assert_type(var, variables.Variable[int])\n+    self.assertIsNone(var.name)\n+\n+  def test_from_value_with_name(self):\n+    var = variables.Variable.from_value(0, name='Zero')\n+    self.assertEqual(var.name, 'Zero')\n \n   def test_multiple_bindings(self):\n     var = variables.Variable((variables.Binding(0), variables.Binding('')))\ndiff --git a/pytype/rewrite/frame_test.py b/pytype/rewrite/frame_test.py\nindex 820b50270..b53ed9001 100644\n--- a/pytype/rewrite/frame_test.py\n+++ b/pytype/rewrite/frame_test.py\n@@ -28,12 +28,35 @@ def _make_frame(self, src: str, name: str = '__main__') -> frame_lib.Frame:\n           name: value.to_variable() for name, value in module_globals.items()}\n     else:\n       initial_locals = initial_globals = {}\n+    self._kw_names = ()\n     return frame_lib.Frame(self.ctx, name, code, initial_locals=initial_locals,\n                            initial_globals=initial_globals)\n \n   def _const_var(self, const, name=None):\n-    var = abstract.PythonConstant(self.ctx, const).to_variable()\n-    return var.with_name(name)\n+    return self.ctx.consts[const].to_variable(name)\n+\n+  def assertConstantVar(self, var, expected):\n+    val = var.get_atomic_value()\n+    self.assertIsInstance(val, abstract.PythonConstant)\n+    self.assertEqual(val.constant, expected)\n+\n+  def run_block(self, block: str, *, consts=()) -> frame_lib.Frame:\n+    \"\"\"Run a block of opcodes without checking frame exit conditions.\"\"\"\n+    code = test_utils.assemble_block(block, consts=consts)\n+    blk = code.order[0].code\n+    n = len(blk)\n+    # Add a NOP at the end so there is always an opcode.next\n+    blk.append(opcodes.NOP(n, blk[-1].line))\n+    frame = frame_lib.Frame(self.ctx, 'test', code.Seal())\n+    frame.stepn(n)\n+    return frame\n+\n+  def run_frame_until(self, code: str, *, condition) -> frame_lib.Frame:\n+    \"\"\"Run a block of opcodes until condition is met.\"\"\"\n+    frame = self._make_frame(code)\n+    while not condition(frame):\n+      frame.step()\n+    return frame\n \n \n class ShadowedNonlocalsTest(unittest.TestCase):\n@@ -41,14 +64,14 @@ class ShadowedNonlocalsTest(unittest.TestCase):\n   def test_enclosing(self):\n     sn = frame_lib._ShadowedNonlocals()\n     sn.add_enclosing('x')\n-    self.assertTrue(sn.has_scope('x', frame_lib._Scope.ENCLOSING))\n-    self.assertCountEqual(sn.get_names(frame_lib._Scope.ENCLOSING), {'x'})\n+    self.assertTrue(sn.has_enclosing('x'))\n+    self.assertCountEqual(sn.get_enclosing_names(), {'x'})\n \n   def test_global(self):\n     sn = frame_lib._ShadowedNonlocals()\n     sn.add_global('x')\n-    self.assertTrue(sn.has_scope('x', frame_lib._Scope.GLOBAL))\n-    self.assertCountEqual(sn.get_names(frame_lib._Scope.GLOBAL), {'x'})\n+    self.assertTrue(sn.has_global('x'))\n+    self.assertCountEqual(sn.get_global_names(), {'x'})\n \n \n class LoadStoreTest(FrameTestBase):\n@@ -56,7 +79,7 @@ class LoadStoreTest(FrameTestBase):\n   def test_store_local_in_module_frame(self):\n     frame = self._make_frame('', name='__main__')\n     frame.step()\n-    var = abstract.PythonConstant(self.ctx, 5).to_variable()\n+    var = self._const_var(5)\n     frame.store_local('x', var)\n     stored = frame.load_local('x')\n     self.assertEqual(stored, var.with_name('x'))\n@@ -65,7 +88,7 @@ def test_store_local_in_module_frame(self):\n   def test_store_local_in_nonmodule_frame(self):\n     frame = self._make_frame('', name='f')\n     frame.step()\n-    var = abstract.PythonConstant(self.ctx, 5).to_variable()\n+    var = self._const_var(5)\n     frame.store_local('x', var)\n     stored = frame.load_local('x')\n     self.assertEqual(stored, var.with_name('x'))\n@@ -75,7 +98,7 @@ def test_store_local_in_nonmodule_frame(self):\n   def test_store_global_in_module_frame(self):\n     frame = self._make_frame('', name='__main__')\n     frame.step()\n-    var = abstract.PythonConstant(self.ctx, 5).to_variable()\n+    var = self._const_var(5)\n     frame.store_global('x', var)\n     stored = frame.load_global('x')\n     self.assertEqual(stored, var.with_name('x'))\n@@ -84,7 +107,7 @@ def test_store_global_in_module_frame(self):\n   def test_store_global_in_nonmodule_frame(self):\n     frame = self._make_frame('', name='f')\n     frame.step()\n-    var = abstract.PythonConstant(self.ctx, 5).to_variable()\n+    var = self._const_var(5)\n     frame.store_global('x', var)\n     stored = frame.load_global('x')\n     self.assertEqual(stored, var.with_name('x'))\n@@ -93,7 +116,7 @@ def test_store_global_in_nonmodule_frame(self):\n \n   def test_overwrite_global_in_module_frame(self):\n     code = test_utils.parse('')\n-    var = abstract.PythonConstant(self.ctx, 5).to_variable()\n+    var = self._const_var(5)\n     frame = frame_lib.Frame(\n         self.ctx, '__main__', code, initial_locals={'x': var},\n         initial_globals={'x': var})\n@@ -102,7 +125,7 @@ def test_overwrite_global_in_module_frame(self):\n     self.assertEqual(frame.load_global('x'), var.with_name('x'))\n     self.assertEqual(frame.load_local('x'), var.with_name('x'))\n \n-    var2 = abstract.PythonConstant(self.ctx, 10).to_variable()\n+    var2 = self._const_var(10)\n     frame.store_global('x', var2)\n \n     self.assertEqual(frame.load_global('x'), var2.with_name('x'))\n@@ -110,7 +133,7 @@ def test_overwrite_global_in_module_frame(self):\n \n   def test_overwrite_global_in_nonmodule_frame(self):\n     code = test_utils.parse('')\n-    var = abstract.PythonConstant(self.ctx, 5).to_variable()\n+    var = self._const_var(5)\n     frame = frame_lib.Frame(self.ctx, 'f', code, initial_globals={'x': var})\n     frame.step()\n \n@@ -118,7 +141,7 @@ def test_overwrite_global_in_nonmodule_frame(self):\n     with self.assertRaises(KeyError):\n       frame.load_local('x')\n \n-    var2 = abstract.PythonConstant(self.ctx, 10).to_variable()\n+    var2 = self._const_var(10)\n     frame.store_global('x', var2)\n \n     self.assertEqual(frame.load_global('x'), var2.with_name('x'))\n@@ -129,7 +152,7 @@ def test_enclosing(self):\n     code = test_utils.parse('')\n     frame = frame_lib.Frame(self.ctx, 'f', code)\n     frame.step()\n-    x = abstract.PythonConstant(self.ctx, 5).to_variable()\n+    x = self._const_var(5)\n     frame.store_enclosing('x', x)\n     with self.assertRaises(KeyError):\n       frame.load_local('x')\n@@ -157,14 +180,13 @@ def test_load_const(self):\n     frame.step()\n     self.assertEqual(len(frame._stack), 1)\n     constant = frame._stack.top().get_atomic_value()\n-    self.assertEqual(constant, abstract.PythonConstant(self.ctx, 42))\n+    self.assertEqual(constant, self.ctx.consts[42])\n \n   def test_store_local(self):\n     frame = self._make_frame('x = 42')\n     frame.run()\n     self.assertIn('x', frame.final_locals)\n-    self.assertEqual(frame.final_locals['x'],\n-                     abstract.PythonConstant(self.ctx, 42))\n+    self.assertEqual(frame.final_locals['x'], self.ctx.consts[42])\n \n   def test_store_global(self):\n     frame = self._make_frame(\"\"\"\n@@ -173,8 +195,7 @@ def test_store_global(self):\n     \"\"\")\n     frame.run()\n     self.assertIn('x', frame.final_locals)\n-    self.assertEqual(frame.final_locals['x'],\n-                     abstract.PythonConstant(self.ctx, 42))\n+    self.assertEqual(frame.final_locals['x'], self.ctx.consts[42])\n \n   def test_function(self):\n     frame = self._make_frame('def f(): pass')\n@@ -231,7 +252,7 @@ def g():\n     self.assertIn('g', f_frame.final_locals)\n     self.assertIn('x', f_frame.final_locals)\n     self.assertCountEqual(\n-        f_frame._shadowed_nonlocals.get_names(frame_lib._Scope.GLOBAL), {'x'})\n+        f_frame._shadowed_nonlocals.get_global_names(), {'x'})\n \n   def test_read_enclosing(self):\n     module_frame = self._make_frame(\"\"\"\n@@ -297,8 +318,7 @@ def __init__(self):\n     module_frame.run()\n     cls = _get(module_frame, 'C', abstract.InterpreterClass)\n     instance = cls.instantiate()\n-    self.assertEqual(instance.get_attribute('x'),\n-                     abstract.PythonConstant(self.ctx, 3))\n+    self.assertEqual(instance.get_attribute('x'), self.ctx.consts[3])\n \n   def test_read_instance_attribute(self):\n     module_frame = self._make_frame(\"\"\"\n@@ -314,8 +334,7 @@ def read(self):\n     read = cast(abstract.InterpreterFunction, cls.members['read'])\n     frame, = read.bind_to(instance).analyze()\n     self.assertIn('x', frame.final_locals)\n-    self.assertEqual(frame.final_locals['x'],\n-                     abstract.PythonConstant(self.ctx, 3))\n+    self.assertEqual(frame.final_locals['x'], self.ctx.consts[3])\n \n   def test_write_and_read_instance_attribute(self):\n     module_frame = self._make_frame(\"\"\"\n@@ -331,8 +350,7 @@ def write_and_read(self):\n                           cls.members['write_and_read'])\n     frame, = write_and_read.bind_to(instance).analyze()\n     self.assertIn('x', frame.final_locals)\n-    self.assertEqual(frame.final_locals['x'],\n-                     abstract.PythonConstant(self.ctx, 3))\n+    self.assertEqual(frame.final_locals['x'], self.ctx.consts[3])\n \n   def test_modify_instance(self):\n     module_frame = self._make_frame(\"\"\"\n@@ -344,7 +362,7 @@ def f(self):\n     \"\"\")\n     module_frame.run()\n     c = _get(module_frame, 'c', abstract.MutableInstance)\n-    self.assertEqual(c.get_attribute('x'), abstract.PythonConstant(self.ctx, 3))\n+    self.assertEqual(c.get_attribute('x'), self.ctx.consts[3])\n \n   def test_overwrite_instance_attribute(self):\n     module_frame = self._make_frame(\"\"\"\n@@ -359,8 +377,7 @@ def g(self):\n     \"\"\")\n     module_frame.run()\n     c = _get(module_frame, 'c', abstract.MutableInstance)\n-    self.assertEqual(c.get_attribute('x'),\n-                     abstract.PythonConstant(self.ctx, None))\n+    self.assertEqual(c.get_attribute('x'), self.ctx.consts[None])\n \n   def test_instance_attribute_multiple_options(self):\n     module_frame = self._make_frame(\"\"\"\n@@ -375,8 +392,19 @@ def __init__(self, rand):\n     instance = _get(module_frame, 'C', abstract.InterpreterClass).instantiate()\n     self.assertEqual(\n         instance.get_attribute('x'),\n-        abstract.Union(self.ctx, (abstract.PythonConstant(self.ctx, 3),\n-                                  abstract.PythonConstant(self.ctx, None))))\n+        abstract.Union(self.ctx, (self.ctx.consts[3], self.ctx.consts[None])))\n+\n+  def test_method_parameter(self):\n+    module_frame = self._make_frame(\"\"\"\n+      class C:\n+        def f(self, x):\n+          self.x = x\n+      c = C()\n+      c.f(0)\n+    \"\"\")\n+    module_frame.run()\n+    instance = _get(module_frame, 'c', abstract.MutableInstance)\n+    self.assertEqual(instance.get_attribute('x'), self.ctx.consts[0])\n \n   def test_multiple_initializers(self):\n     module_frame = self._make_frame(\"\"\"\n@@ -394,8 +422,7 @@ def custom_init(self, rand):\n     instance = cls.instantiate()\n     self.assertEqual(\n         instance.get_attribute('x'),\n-        abstract.Union(self.ctx, (abstract.PythonConstant(self.ctx, 3),\n-                                  abstract.PythonConstant(self.ctx, None))))\n+        abstract.Union(self.ctx, (self.ctx.consts[3], self.ctx.consts[None])))\n \n   def test_return(self):\n     module_frame = self._make_frame(\"\"\"\n@@ -410,8 +437,7 @@ def f(rand):\n     f_frame, = f.analyze()\n     self.assertEqual(\n         f_frame.get_return_value(),\n-        abstract.Union(self.ctx, (abstract.PythonConstant(self.ctx, 3),\n-                                  abstract.PythonConstant(self.ctx, None))))\n+        abstract.Union(self.ctx, (self.ctx.consts[3], self.ctx.consts[None])))\n \n   def test_stack(self):\n     module_frame = self._make_frame('def f(): pass')\n@@ -525,51 +551,90 @@ class ComprehensionAccumulatorTest(FrameTestBase):\n   \"\"\"Test accumulating results in a comprehension.\"\"\"\n \n   def test_list_append(self):\n-    block = [\n-        opcodes.BUILD_LIST(0, 0, 0, None),\n-        opcodes.LOAD_CONST(1, 0, 0, 1),\n-        opcodes.LOAD_CONST(2, 0, 1, 2),\n-        opcodes.LIST_APPEND(3, 0, 2, None),\n-        opcodes.NOP(4, 0)\n-    ]\n-    code = test_utils.FakeOrderedCode([block], [1, 2])\n-    frame = frame_lib.Frame(self.ctx, 'test', code.Seal())\n-    frame.stepn(4)\n+    frame = self.run_block(\"\"\"\n+      BUILD_LIST 0\n+      LOAD_CONST 0\n+      LOAD_CONST 1\n+      LIST_APPEND 2\n+    \"\"\", consts=[1, 2])\n     target_var = frame._stack.peek(2)\n     target = abstract.get_atomic_constant(target_var)\n     self.assertEqual(target, [self._const_var(2)])\n \n   def test_set_add(self):\n-    block = [\n-        opcodes.BUILD_SET(0, 0, 0, None),\n-        opcodes.LOAD_CONST(1, 0, 0, 1),\n-        opcodes.LOAD_CONST(2, 0, 1, 2),\n-        opcodes.SET_ADD(3, 0, 2, None),\n-        opcodes.NOP(4, 0)\n-    ]\n-    code = test_utils.FakeOrderedCode([block], [1, 2])\n-    frame = frame_lib.Frame(self.ctx, 'test', code.Seal())\n-    frame.stepn(4)\n+    frame = self.run_block(\"\"\"\n+      BUILD_SET 0\n+      LOAD_CONST 0\n+      LOAD_CONST 1\n+      SET_ADD 2\n+    \"\"\", consts=[1, 2])\n     target_var = frame._stack.peek(2)\n     target = abstract.get_atomic_constant(target_var)\n     self.assertEqual(target, {self._const_var(2)})\n \n   def test_map_add(self):\n-    block = [\n-        opcodes.BUILD_MAP(0, 0, 0, None),\n-        opcodes.LOAD_CONST(1, 0, 0, 1),\n-        opcodes.LOAD_CONST(2, 0, 1, 2),\n-        opcodes.LOAD_CONST(3, 0, 2, 3),\n-        opcodes.MAP_ADD(4, 0, 2, None),\n-        opcodes.NOP(5, 0)\n-    ]\n-    code = test_utils.FakeOrderedCode([block], [1, 2, 3])\n-    frame = frame_lib.Frame(self.ctx, 'test', code.Seal())\n-    frame.stepn(5)\n+    frame = self.run_block(\"\"\"\n+      BUILD_MAP 0\n+      LOAD_CONST 0\n+      LOAD_CONST 1\n+      LOAD_CONST 2\n+      MAP_ADD 2\n+    \"\"\", consts=[1, 2, 3])\n     target_var = frame._stack.peek(2)\n     target = abstract.get_atomic_constant(target_var)\n     self.assertEqual(target, {self._const_var(2): self._const_var(3)})\n \n \n+class FunctionTest(FrameTestBase):\n+  \"\"\"Test making and calling functions.\"\"\"\n+\n+  def _make_function(self, code, name):\n+    module_frame = self._make_frame(code, name='__main__')\n+    module_frame.run()\n+    return _get(module_frame, name, _FrameFunction)\n+\n+  def _run_until_call(self, code):\n+    def cond(frame):\n+      return frame.current_opcode.name.startswith('CALL')\n+    frame = self.run_frame_until(code, condition=cond)\n+    return frame\n+\n+  @test_utils.skipBeforePy((3, 11), 'Relies on 3.11+ bytecode')\n+  def test_make_function(self):\n+    f = self._make_function(\"\"\"\n+      def f(x, /, y, z, *, a, b, c):\n+        pass\n+    \"\"\", 'f')\n+    self.assertIsInstance(f, abstract.InterpreterFunction)\n+    self.assertEqual(f.name, 'f')\n+    sig = f.signatures[0]\n+    self.assertEqual(repr(sig), 'def f(x, /, y, z, *, a, b, c) -> Any')\n+\n+  @test_utils.skipBeforePy((3, 11), 'Relies on 3.11+ bytecode')\n+  def test_function_annotations(self):\n+    f = self._make_function(\"\"\"\n+      def f(x: int, /, y: str, *, a: int, b: int = 1):\n+        pass\n+    \"\"\", 'f')\n+    self.assertIsInstance(f, abstract.InterpreterFunction)\n+    self.assertEqual(f.name, 'f')\n+    sig = f.signatures[0]\n+    self.assertEqual(repr(sig), 'def f(x, /, y, *, a, b) -> Any')\n+\n+  @test_utils.skipBeforePy((3, 11), 'Relies on 3.11+ bytecode')\n+  def test_function_call_kwargs(self):\n+    frame = self._run_until_call(\"\"\"\n+      def f(x, *, y):\n+        pass\n+      f(1, y=2)\n+    \"\"\")\n+    self.assertEqual(frame._kw_names, ('y',))\n+    oparg = frame.current_opcode.arg  # pytype: disable=attribute-error\n+    _, _, *args = frame._stack.popn(oparg + 2)\n+    callargs = frame._make_function_args(args)\n+    self.assertConstantVar(callargs.posargs[0], 1)\n+    self.assertConstantVar(callargs.kwargs['y'], 2)\n+\n+\n if __name__ == '__main__':\n   unittest.main()\ndiff --git a/pytype/rewrite/load_abstract_test.py b/pytype/rewrite/load_abstract_test.py\nindex 0ee493d85..bb91076f7 100644\n--- a/pytype/rewrite/load_abstract_test.py\n+++ b/pytype/rewrite/load_abstract_test.py\n@@ -1,4 +1,8 @@\n+import numbers\n+\n+from pytype.rewrite.abstract import abstract\n from pytype.rewrite.tests import test_utils\n+\n import unittest\n \n \n@@ -10,5 +14,48 @@ def test_basic(self):\n     self.assertIn('__name__', module_globals)\n \n \n+class LoadBuiltinByNameTest(test_utils.ContextfulTestBase):\n+\n+  def test_class(self):\n+    int_cls = self.ctx.abstract_loader.load_builtin_by_name('int')\n+    self.assertIsInstance(int_cls, abstract.SimpleClass)\n+    self.assertEqual(int_cls.name, 'int')\n+\n+  def test_function(self):\n+    abs_func = self.ctx.abstract_loader.load_builtin_by_name('abs')\n+    self.assertIsInstance(abs_func, abstract.PytdFunction)\n+    self.assertEqual(abs_func.name, 'abs')\n+\n+  def test_constant(self):\n+    ellipsis = self.ctx.abstract_loader.load_builtin_by_name('Ellipsis')\n+    self.assertIsInstance(ellipsis, abstract.PythonConstant)\n+    self.assertEqual(ellipsis.constant, Ellipsis)\n+\n+  def test_none(self):\n+    self.assertIs(self.ctx.abstract_loader.load_builtin_by_name('None'),\n+                  self.ctx.consts[None])\n+    self.assertIs(self.ctx.abstract_loader.load_builtin_by_name('NoneType'),\n+                  self.ctx.consts[None])\n+\n+\n+class LoadRawTypeTest(test_utils.ContextfulTestBase):\n+\n+  def test_builtin_type(self):\n+    t = self.ctx.abstract_loader.load_raw_type(int)\n+    self.assertIsInstance(t, abstract.SimpleClass)\n+    self.assertEqual(t.name, 'int')\n+    self.assertEqual(t.module, 'builtins')\n+\n+  def test_stdlib_type(self):\n+    t = self.ctx.abstract_loader.load_raw_type(numbers.Number)\n+    self.assertIsInstance(t, abstract.SimpleClass)\n+    self.assertEqual(t.name, 'Number')\n+    self.assertEqual(t.module, 'numbers')\n+\n+  def test_nonetype(self):\n+    t = self.ctx.abstract_loader.load_raw_type(type(None))\n+    self.assertIs(t, self.ctx.consts[None])\n+\n+\n if __name__ == '__main__':\n   unittest.main()\ndiff --git a/pytype/rewrite/output_test.py b/pytype/rewrite/output_test.py\nindex 06a7eaf9d..8d4fe71a4 100644\n--- a/pytype/rewrite/output_test.py\n+++ b/pytype/rewrite/output_test.py\n@@ -9,14 +9,13 @@\n import unittest\n \n \n-def _make(src: str) -> abstract.BaseValue:\n-  vm = vm_lib.VirtualMachine.from_source(textwrap.dedent(src))\n-  vm._run_module()\n-  return list(vm._module_frame.final_locals.values())[-1]\n-\n-\n class OutputTestBase(test_utils.ContextfulTestBase):\n \n+  def make_value(self, src: str) -> abstract.BaseValue:\n+    vm = vm_lib.VirtualMachine.from_source(textwrap.dedent(src), self.ctx)\n+    vm._run_module()\n+    return list(vm._module_frame.final_locals.values())[-1]\n+\n   def assertPytdEqual(self, pytd_node, expected_str):\n     actual_str = pytd_utils.Print(pytd_node).strip()\n     expected_str = textwrap.dedent(expected_str).strip()\n@@ -26,7 +25,7 @@ def assertPytdEqual(self, pytd_node, expected_str):\n class ClassToPytdDefTest(OutputTestBase):\n \n   def test_constant(self):\n-    cls = _make(\"\"\"\n+    cls = self.make_value(\"\"\"\n       class C:\n         X = 0\n     \"\"\")\n@@ -37,7 +36,7 @@ class C:\n     \"\"\")\n \n   def test_method(self):\n-    cls = _make(\"\"\"\n+    cls = self.make_value(\"\"\"\n       class C:\n         def f(self):\n           return 0\n@@ -49,7 +48,7 @@ def f(self) -> int: ...\n     \"\"\")\n \n   def test_nested_class(self):\n-    cls = _make(\"\"\"\n+    cls = self.make_value(\"\"\"\n       class C:\n         class D:\n           pass\n@@ -61,7 +60,7 @@ class D: ...\n     \"\"\")\n \n   def test_instance_attribute(self):\n-    cls = _make(\"\"\"\n+    cls = self.make_value(\"\"\"\n       class C:\n         def __init__(self):\n           self.x = 42\n@@ -77,7 +76,7 @@ def __init__(self) -> None: ...\n class FunctionToPytdDefTest(OutputTestBase):\n \n   def test_basic(self):\n-    func = _make(\"\"\"\n+    func = self.make_value(\"\"\"\n       def f(x, /, y, *args, z, **kwargs):\n         return 42\n     \"\"\")\n@@ -91,7 +90,7 @@ def f(x, /, y, *args, z, **kwargs) -> int: ...\n   # signature objects.\n   # pytype: disable=attribute-error\n   def test_param_annotation(self):\n-    func = _make(\"\"\"\n+    func = self.make_value(\"\"\"\n       def f(x):\n         pass\n     \"\"\")\n@@ -101,7 +100,7 @@ def f(x):\n     self.assertPytdEqual(pytd_func, 'def f(x: C) -> None: ...')\n \n   def test_return_annotation(self):\n-    func = _make(\"\"\"\n+    func = self.make_value(\"\"\"\n       def f():\n         pass\n     \"\"\")\n@@ -111,11 +110,11 @@ def f():\n     self.assertPytdEqual(pytd_func, 'def f() -> C: ...')\n \n   def test_default(self):\n-    func = _make(\"\"\"\n+    func = self.make_value(\"\"\"\n       def f(x):\n         pass\n     \"\"\")\n-    func.signatures[0].defaults['x'] = abstract.PythonConstant(self.ctx, 0)\n+    func.signatures[0].defaults['x'] = self.ctx.consts[0]\n     pytd_func = self.ctx.pytd_converter.to_pytd_def(func)\n     self.assertPytdEqual(pytd_func, 'def f(x = ...) -> None: ...')\n   # pytype: enable=attribute-error\n@@ -124,12 +123,11 @@ def f(x):\n class ToPytdTypeTest(OutputTestBase):\n \n   def test_any(self):\n-    self.assertEqual(self.ctx.pytd_converter.to_pytd_type(self.ctx.singles.Any),\n+    self.assertEqual(self.ctx.pytd_converter.to_pytd_type(self.ctx.consts.Any),\n                      pytd.AnythingType())\n \n   def test_constant(self):\n-    t = self.ctx.pytd_converter.to_pytd_type(\n-        abstract.PythonConstant(self.ctx, 0))\n+    t = self.ctx.pytd_converter.to_pytd_type(self.ctx.consts[0])\n     self.assertPytdEqual(t, 'int')\n \n   def test_class(self):\n@@ -148,7 +146,7 @@ def test_frozen_instance(self):\n     self.assertPytdEqual(self.ctx.pytd_converter.to_pytd_type(instance), 'C')\n \n   def test_precise_callable(self):\n-    func = _make(\"\"\"\n+    func = self.make_value(\"\"\"\n       def f(x):\n         pass\n     \"\"\")\n@@ -156,7 +154,7 @@ def f(x):\n                          'Callable[[Any], None]')\n \n   def test_any_args_callable(self):\n-    func = _make(\"\"\"\n+    func = self.make_value(\"\"\"\n       def f(*args):\n         return 42\n     \"\"\")\n@@ -164,8 +162,8 @@ def f(*args):\n                          'Callable[..., int]')\n \n   def test_union(self):\n-    union = abstract.Union(self.ctx, (abstract.PythonConstant(self.ctx, 0),\n-                                      abstract.PythonConstant(self.ctx, None)))\n+    union = abstract.Union(\n+        self.ctx, (self.ctx.consts[0], self.ctx.consts[None]))\n     self.assertPytdEqual(self.ctx.pytd_converter.to_pytd_type(union),\n                          'Optional[int]')\n \n@@ -173,9 +171,8 @@ def test_union(self):\n class ToPytdInstanceTypeTest(OutputTestBase):\n \n   def test_any(self):\n-    self.assertEqual(\n-        self.ctx.pytd_converter.to_pytd_type_of_instance(self.ctx.singles.Any),\n-        pytd.AnythingType())\n+    t = self.ctx.pytd_converter.to_pytd_type_of_instance(self.ctx.consts.Any)\n+    self.assertEqual(t, pytd.AnythingType())\n \n   def test_class(self):\n     cls = abstract.SimpleClass(self.ctx, 'C', {})\ndiff --git a/pytype/rewrite/overlays/special_builtins_test.py b/pytype/rewrite/overlays/special_builtins_test.py\nindex 12019f0fa..0c4228feb 100644\n--- a/pytype/rewrite/overlays/special_builtins_test.py\n+++ b/pytype/rewrite/overlays/special_builtins_test.py\n@@ -10,11 +10,10 @@ class AssertTypeTest(unittest.TestCase):\n   def test_types_match(self):\n     ctx = context.Context()\n     assert_type_func = special_builtins.AssertType(ctx)\n-    var = abstract.PythonConstant(ctx, 0).to_variable()\n+    var = ctx.consts[0].to_variable()\n     typ = abstract.SimpleClass(ctx, 'int', {}).to_variable()\n     ret = assert_type_func.call(abstract.Args(posargs=(var, typ)))\n-    self.assertEqual(ret.get_return_value(),\n-                     abstract.PythonConstant(ctx, None))\n+    self.assertEqual(ret.get_return_value(), ctx.consts[None])\n \n \n if __name__ == '__main__':\ndiff --git a/pytype/rewrite/stack_test.py b/pytype/rewrite/stack_test.py\nindex e103fced3..2b740ee4d 100644\n--- a/pytype/rewrite/stack_test.py\n+++ b/pytype/rewrite/stack_test.py\n@@ -1,5 +1,4 @@\n from pytype.rewrite import stack\n-from pytype.rewrite.abstract import abstract\n from pytype.rewrite.tests import test_utils\n \n import unittest\n@@ -8,7 +7,7 @@\n class DataStackTest(test_utils.ContextfulTestBase):\n \n   def _var(self, val):\n-    return abstract.PythonConstant(self.ctx, val).to_variable()\n+    return self.ctx.consts[val].to_variable()\n \n   def test_push(self):\n     s = stack.DataStack()\n@@ -19,7 +18,7 @@ def test_push(self):\n   def test_pop(self):\n     s = stack.DataStack()\n     var = self._var(5)\n-    var = abstract.PythonConstant(self.ctx, 5).to_variable()\n+    var = self.ctx.consts[5].to_variable()\n     s.push(var)\n     popped = s.pop()\n     self.assertEqual(popped, var)\ndiff --git a/pytype/rewrite/tests/CMakeLists.txt b/pytype/rewrite/tests/CMakeLists.txt\nindex 59514c572..e8d4aad83 100644\n--- a/pytype/rewrite/tests/CMakeLists.txt\n+++ b/pytype/rewrite/tests/CMakeLists.txt\n@@ -19,5 +19,16 @@ py_test(\n   SRCS\n     test_basic.py\n   DEPS\n+    pytype.rewrite.tests.test_utils\n     pytype.tests.test_base\n )\n+\n+py_test(\n+  NAME\n+    test_utils_test\n+  SRCS\n+    test_utils_test.py\n+  DEPS\n+    .test_utils\n+    pytype.pyc.pyc\n+)\ndiff --git a/pytype/rewrite/tests/test_basic.py b/pytype/rewrite/tests/test_basic.py\nindex 21e590668..f0dfbeebf 100644\n--- a/pytype/rewrite/tests/test_basic.py\n+++ b/pytype/rewrite/tests/test_basic.py\n@@ -1,4 +1,5 @@\n \"\"\"Basic functional tests.\"\"\"\n+from pytype.rewrite.tests import test_utils\n from pytype.tests import test_base\n \n \n@@ -31,6 +32,14 @@ def f(x):\n       f(0)\n     \"\"\")\n \n+  @test_utils.skipBeforePy((3, 11), 'Relies on 3.11+ bytecode')\n+  def test_function_kwargs(self):\n+    self.Check(\"\"\"\n+      def f(x, *, y):\n+        return x\n+      f(0, y=1)\n+    \"\"\")\n+\n   def test_class(self):\n     self.Check(\"\"\"\n       class C:\n@@ -66,6 +75,21 @@ def test_assert_type(self):\n     \"\"\")\n     self.assertErrorSequences(errors, {'e': ['Expected: str', 'Actual: int']})\n \n+  def test_infer_class_body(self):\n+    ty = self.Infer(\"\"\"\n+      class C:\n+        def __init__(self):\n+          self.x = 3\n+        def f(self):\n+          return self.x\n+    \"\"\")\n+    self.assertTypesMatchPytd(ty, \"\"\"\n+      class C:\n+        x: int\n+        def __init__(self) -> None: ...\n+        def f(self) -> int: ...\n+    \"\"\")\n+\n \n if __name__ == '__main__':\n   test_base.main()\ndiff --git a/pytype/rewrite/tests/test_utils.py b/pytype/rewrite/tests/test_utils.py\nindex ee68b133d..185b3d588 100644\n--- a/pytype/rewrite/tests/test_utils.py\n+++ b/pytype/rewrite/tests/test_utils.py\n@@ -1,5 +1,6 @@\n \"\"\"Test utilities.\"\"\"\n \n+import re\n import sys\n import textwrap\n from typing import Sequence\n@@ -45,6 +46,29 @@ def __init__(self, ops: Sequence[Sequence[opcodes.Opcode]], consts=()):\n     self.consts = consts\n \n \n+# pylint: disable=invalid-name\n+# Use camel-case to match the unittest.skip* methods.\n+def skipIfPy(*versions, reason):\n+  return unittest.skipIf(sys.version_info[:2] in versions, reason)\n+\n+\n+def skipUnlessPy(*versions, reason):\n+  return unittest.skipUnless(sys.version_info[:2] in versions, reason)\n+\n+\n+def skipBeforePy(version, reason):\n+  return unittest.skipIf(sys.version_info[:2] < version, reason)\n+\n+\n+def skipFromPy(version, reason):\n+  return unittest.skipUnless(sys.version_info[:2] < version, reason)\n+\n+\n+def skipOnWin32(reason):\n+  return unittest.skipIf(sys.platform == 'win32', reason)\n+# pylint: enable=invalid-name\n+\n+\n def parse(src: str) -> blocks.OrderedCode:\n   code = pyc.compile_src(\n       src=textwrap.dedent(src),\n@@ -55,3 +79,53 @@ def parse(src: str) -> blocks.OrderedCode:\n   )\n   ordered_code, unused_block_graph = blocks.process_code(code)\n   return ordered_code\n+\n+\n+def assemble_block(bytecode: str, *, consts=()) -> FakeOrderedCode:\n+  \"\"\"Generate a block of opcodes for tests.\n+\n+  Args:\n+    bytecode: A block of opcodes\n+    consts: A sequence of constants (co_consts in the compiled code)\n+\n+  Returns:\n+    A FakeOrderedCode\n+\n+  The bytecode is a block of text, one opcode per line, in the format\n+    # line <lineno>\n+    OP_WITH_ARG arg  # comment\n+    OP  # comment\n+    ...\n+\n+  Blank lines are ignored.\n+\n+  The line numbers are optional, all opcodes will get lineno=1 if omitted. If a\n+  line number is supplied, all following opcodes get that line number until\n+  another line number is encountered.\n+  \"\"\"\n+\n+  lines = textwrap.dedent(bytecode).split('\\n')\n+  ret = []\n+  idx, lineno = 0, 1\n+  for line in lines:\n+    if m := re.match(r'# line (\\d+)', line.strip()):\n+      lineno = int(m.group(1))\n+      continue\n+    line = re.sub(r'#.*$', '', line)  # allow comments\n+    parts = line.split()\n+    if not parts:\n+      continue\n+    if len(parts) == 1:\n+      op, = parts\n+      arg = None\n+    else:\n+      op, arg, *extra = parts\n+      assert not extra, extra\n+      arg = int(arg)\n+    op_cls = getattr(opcodes, op)\n+    if arg is not None:\n+      ret.append(op_cls(idx, lineno, arg, None))\n+    else:\n+      ret.append(op_cls(idx, lineno))\n+    idx += 1\n+  return FakeOrderedCode([ret], consts)\ndiff --git a/pytype/rewrite/tests/test_utils_test.py b/pytype/rewrite/tests/test_utils_test.py\nnew file mode 100644\nindex 000000000..7d8f233a1\n--- /dev/null\n+++ b/pytype/rewrite/tests/test_utils_test.py\n@@ -0,0 +1,39 @@\n+\"\"\"Tests for test utilities.\"\"\"\n+\n+from pytype.pyc import opcodes\n+from pytype.rewrite.tests import test_utils\n+\n+import unittest\n+\n+\n+class TestUtilsTest(unittest.TestCase):\n+\n+  def test_assemble_block(self):\n+    block = \"\"\"\n+      # line 1\n+      BUILD_SET 0\n+      LOAD_CONST 0\n+      # line 2\n+      LOAD_CONST 1\n+      SET_ADD 2\n+      # line 3\n+      RETURN_VALUE\n+    \"\"\"\n+    expected = [\n+        opcodes.BUILD_SET(0, 1, 0, None),\n+        opcodes.LOAD_CONST(1, 1, 0, 1),\n+        opcodes.LOAD_CONST(2, 2, 1, 2),\n+        opcodes.SET_ADD(3, 2, 2, None),\n+        opcodes.RETURN_VALUE(4, 3)\n+    ]\n+    actual = test_utils.assemble_block(block)\n+    for a, e in zip(actual.order[0].code, expected):\n+      self.assertEqual(a.__class__, e.__class__)\n+      self.assertEqual(a.index, e.index)\n+      self.assertEqual(a.line, e.line)\n+      if isinstance(a, opcodes.OpcodeWithArg):\n+        self.assertEqual(a.arg, e.arg)  # pytype: disable=attribute-error\n+\n+\n+if __name__ == '__main__':\n+  unittest.main()\n",
    "problem_statement": "Update pytype_runner.py - change escape_ninja_path to escape all the ninja path escape-needing characters\nThis fixes https://github.com/google/pytype/issues/499\r\n\r\nUnfortunately, I was not able to get pytype running on my machine, so this commit is just based on what seems like the right idea to me, and hopefully it can be verified to be correct by a maintainer and then merged.\n",
    "environment_setup_commit": "52d8e44d739083fdb4d0e45145ca6397ad713e63",
    "pr_url": "https://github.com/google/pytype/pull/1611",
    "issue_url": "https://github.com/google/pytype/issues/1608",
    "issue_numbers": [
        "1608"
    ]
}